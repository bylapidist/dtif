{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://dtif.lapidist.net/schema/core.json",
  "title": "Design Token Interchange Format",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string",
      "title": "Schema declaration",
      "description": "Optional JSON Schema identifier that helps tooling discover compatible vocabularies.",
      "$comment": "Format and serialisation §format: documents MAY declare $schema for tooling introspection."
    },
    "$version": {
      "type": "string",
      "title": "Document version",
      "description": "Semantic Versioning identifier for the token document per Architecture and model §versioning.",
      "$comment": "Architecture and model §versioning.",
      "pattern": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-(?:0|[1-9]\\d*|[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|[a-zA-Z-][0-9a-zA-Z-]*))*)?(?:\\+[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*)?$"
    },
    "$extensions": {
      "title": "Document extensions",
      "description": "Namespaced metadata that applies to the entire document per Format and serialisation §$extensions.",
      "$comment": "Format and serialisation §$extensions.",
      "allOf": [{ "$ref": "#/$defs/extensions" }]
    },
    "$overrides": {
      "title": "Overrides",
      "description": "Conditional overrides evaluated in order per Theming and overrides §$overrides.",
      "$comment": "Theming and overrides §$overrides.",
      "type": "array",
      "items": { "$ref": "#/$defs/override" }
    }
  },
  "patternProperties": {
    "^(?!\\$)": { "$ref": "#/$defs/node" },
    "^\\$": {}
  },
  "unevaluatedProperties": false,
  "$defs": {
    "pointer": {
      "title": "DTIF pointer reference",
      "description": "JSON Pointer string optionally prefixed by a relative path or HTTP(S) URI with a fragment per Format and serialisation §$ref.",
      "type": "string",
      "allOf": [
        {
          "$comment": "RFC 6901 pointer grammar with mandatory # fragment (Format and serialisation §$ref).",
          "pattern": "^(?:#|[^#]+#)(?:\\/[^~\\/]*(?:~[01][^~\\/]*)*)*$"
        },
        {
          "$comment": "Directory traversal segments ../ at the start of the path are invalid (Format and serialisation §$ref step 1).",
          "not": { "pattern": "^\\.\\.(?:\\/|\\?|#|$)" }
        },
        {
          "$comment": "Directory traversal segments ../ inside the path before the fragment are invalid (Format and serialisation §$ref step 1).",
          "not": { "pattern": "^[^#]*\\/\\.\\.(?:\\/|\\?|#|$)" }
        },
        {
          "$comment": "Percent-encoded .. segments (%2e%2e) are also rejected (Format and serialisation §$ref step 1).",
          "not": { "pattern": "^[^#]*%(?:2[eE])%(?:2[eE])" }
        },
        {
          "if": { "pattern": "^[a-zA-Z][a-zA-Z0-9+.-]*:\/\/" },
          "then": { "pattern": "^https?:\/\/" }
        }
      ]
    },
    "reference": {
      "title": "Pointer alias",
      "description": "Object aliasing another token via $ref per Token types §value.",
      "$comment": "Token types §value: alias objects contain only $ref and MUST resolve to the same $type.",
      "type": "object",
      "required": ["$ref"],
      "properties": {
        "$ref": {
          "title": "Alias target",
          "description": "Pointer to the referenced token per Format and serialisation §$ref.",
          "allOf": [{ "$ref": "#/$defs/pointer" }]
        }
      },
      "additionalProperties": false
    },
    "colorReference": {
      "oneOf": [{ "$ref": "#/$defs/color" }, { "$ref": "#/$defs/reference" }]
    },
    "dimensionReference": {
      "oneOf": [{ "$ref": "#/$defs/dimension" }, { "$ref": "#/$defs/reference" }]
    },
    "fontDimensionReference": { "$ref": "#/$defs/font-dimension" },
    "lengthDimensionReference": {
      "oneOf": [{ "$ref": "#/$defs/length-dimension" }, { "$ref": "#/$defs/reference" }]
    },
    "angleDimensionReference": {
      "oneOf": [{ "$ref": "#/$defs/angle-dimension" }, { "$ref": "#/$defs/reference" }]
    },
    "css-ident": {
      "type": "string",
      "pattern": "^-{0,2}[A-Za-z_][A-Za-z0-9_-]*$",
      "$comment": "MUST conform to CSS <ident> / <dashed-ident> productions (css-values-4)."
    },
    "type-identifier": {
      "title": "Token type identifier",
      "description": "Registered DTIF $type or vendor-defined identifier per Format and serialisation §$type.",
      "type": "string",
      "pattern": "^(?:[A-Za-z][A-Za-z0-9_-]*)(?:\\.[A-Za-z0-9_-]+)*$",
      "$comment": "Format and serialisation §$type: registry types include border, color, component, cursor, dimension, duration, easing, elevation, filter, font, fontFace, gradient, line-height, motion, opacity, shadow, strokeStyle, typography, and z-index. Vendors MAY mint additional identifiers and SHOULD namespace them (Extensibility §extensibility) but the schema accepts any dot-separated ASCII identifier without whitespace.",
      "examples": ["color", "typography", "com.example.tokens.radius"]
    },
    "metadata-members": {
      "title": "Metadata members",
      "description": "Optional metadata fields defined in Metadata §metadata applied to tokens and collections.",
      "$comment": "Metadata §metadata table.",
      "properties": {
        "$description": {
          "type": "string",
          "title": "Description",
          "description": "Human-readable explanation preserved for design intent per Metadata §metadata.",
          "$comment": "Metadata table: $description is optional free-form text."
        },
        "$extensions": {
          "title": "Extensions",
          "description": "Namespaced metadata preserved by consumers per Format and serialisation §$extensions.",
          "$comment": "Format and serialisation §$extensions.",
          "allOf": [{ "$ref": "#/$defs/extensions" }]
        },
        "$deprecated": {
          "title": "Deprecation metadata",
          "description": "Boolean indicator or replacement pointer per Metadata §metadata.",
          "$comment": "Metadata table: $deprecated MAY be a boolean or an object with $replacement.",
          "oneOf": [
            { "type": "boolean" },
            {
              "type": "object",
              "required": ["$replacement"],
              "properties": {
                "$replacement": {
                  "title": "Replacement token pointer",
                  "description": "Pointer to the successor token that MUST resolve to the same $type per Metadata §metadata.",
                  "allOf": [{ "$ref": "#/$defs/pointer" }]
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "$lastModified": {
          "type": "string",
          "format": "date-time",
          "title": "Last modified timestamp",
          "description": "RFC 3339 date-time recording governance actions per Metadata §metadata.",
          "$comment": "Metadata table: $lastModified establishes the lower bound for $lastUsed."
        },
        "$lastUsed": {
          "type": "string",
          "format": "date-time",
          "title": "Last used timestamp",
          "description": "RFC 3339 date-time capturing usage telemetry per Metadata §metadata.",
          "$comment": "Metadata table: $lastUsed MUST NOT precede $lastModified and requires $usageCount > 0."
        },
        "$usageCount": {
          "type": "integer",
          "minimum": 0,
          "title": "Usage count",
          "description": "Non-negative adoption counter per Metadata §metadata.",
          "$comment": "Metadata table: $usageCount records adoption and pairs with $lastUsed when greater than zero."
        },
        "$author": {
          "title": "Author",
          "description": "Contributor name without leading or trailing whitespace per Metadata §metadata.",
          "$comment": "Metadata table: $author MUST be a non-empty trimmed string.",
          "allOf": [{ "$ref": "#/$defs/trimmedString" }]
        },
        "$tags": {
          "title": "Tags",
          "description": "Unique classification strings free of surrounding whitespace per Metadata §metadata.",
          "$comment": "Metadata table: $tags MUST be an array of trimmed, unique strings.",
          "allOf": [{ "$ref": "#/$defs/tags" }]
        },
        "$hash": {
          "title": "Hash",
          "description": "Stable identifier without whitespace for change tracking per Metadata §metadata.",
          "$comment": "Metadata table: $hash MUST be non-empty and contain no whitespace.",
          "allOf": [{ "$ref": "#/$defs/hashString" }]
        }
      }
    },
    "override-core": {
      "title": "Override rule members",
      "description": "Shared override members applied to $overrides entries per Theming and overrides §$overrides.",
      "$comment": "Theming and overrides §$overrides.",
      "type": "object",
      "properties": {
        "$token": {
          "title": "Target token",
          "description": "Pointer to the token being overridden per Theming and overrides §$overrides.",
          "allOf": [{ "$ref": "#/$defs/pointer" }]
        },
        "$when": {
          "type": "object",
          "minProperties": 1,
          "title": "Override conditions",
          "description": "Context map describing when the override applies per Theming and overrides §$overrides.",
          "$comment": "Override contexts MUST declare at least one condition per Theming and overrides §$overrides.",
          "propertyNames": {
            "minLength": 1,
            "$comment": "Condition keys MUST be non-empty strings."
          }
        },
        "$ref": {
          "title": "Override reference",
          "description": "Pointer to the replacement token per Theming and overrides §$overrides.",
          "allOf": [{ "$ref": "#/$defs/pointer" }]
        },
        "$value": {
          "title": "Inline override value",
          "description": "Direct replacement that MUST satisfy the overridden token's $type per Theming and overrides §$overrides.",
          "$comment": "Inline override values must conform to the target token's $type."
        },
        "$fallback": {
          "title": "Fallback chain",
          "description": "Single fallback object or array evaluated when primary override resolution fails per Theming and overrides §$overrides.",
          "allOf": [{ "$ref": "#/$defs/fallback" }]
        }
      },
      "required": ["$token", "$when"],
      "additionalProperties": false
    },
    "fallback-entry-core": {
      "title": "Fallback entry members",
      "description": "Shared fallback members evaluated when overrides fail per Theming and overrides §$overrides.",
      "$comment": "Theming and overrides §$overrides.",
      "type": "object",
      "properties": {
        "$ref": {
          "title": "Fallback reference",
          "description": "Pointer to an alternate token per Theming and overrides §$overrides.",
          "allOf": [{ "$ref": "#/$defs/pointer" }]
        },
        "$value": {
          "title": "Inline fallback value",
          "description": "Inline fallback that MUST conform to the overridden token's $type per Theming and overrides §$overrides.",
          "$comment": "Fallback values must conform to the overridden token's $type."
        },
        "$fallback": {
          "title": "Nested fallback",
          "description": "Optional nested fallback chain evaluated when this entry fails per Theming and overrides §$overrides.",
          "allOf": [{ "$ref": "#/$defs/fallback" }]
        }
      },
      "additionalProperties": false
    },
    "token-core": {
      "type": "object",
      "properties": {
        "$type": { "$ref": "#/$defs/type-identifier" },
        "$value": {},
        "$ref": { "$ref": "#/$defs/pointer" }
      },
      "patternProperties": {
        "^\\$": {}
      },
      "unevaluatedProperties": false,
      "allOf": [
        {
          "oneOf": [
            { "required": ["$value"], "not": { "required": ["$ref"] } },
            { "required": ["$ref"], "not": { "required": ["$value"] } }
          ]
        },
        {
          "if": { "required": ["$ref"] },
          "then": { "required": ["$type"] }
        },
        {
          "if": { "properties": { "$type": { "const": "dimension" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": {
                "oneOf": [{ "$ref": "#/$defs/dimension" }, { "$ref": "#/$defs/function" }]
              }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "color" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": { "oneOf": [{ "$ref": "#/$defs/color" }, { "$ref": "#/$defs/function" }] }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "font" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": { "oneOf": [{ "$ref": "#/$defs/font" }, { "$ref": "#/$defs/function" }] }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "fontFace" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": {
                "oneOf": [{ "$ref": "#/$defs/fontFace" }, { "$ref": "#/$defs/function" }]
              }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "line-height" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": {
                "oneOf": [{ "$ref": "#/$defs/line-height" }, { "$ref": "#/$defs/function" }]
              }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "typography" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": {
                "oneOf": [{ "$ref": "#/$defs/typography" }, { "$ref": "#/$defs/function" }]
              }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "border" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": { "oneOf": [{ "$ref": "#/$defs/border" }, { "$ref": "#/$defs/function" }] }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "strokeStyle" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": {
                "oneOf": [{ "$ref": "#/$defs/strokeStyle" }, { "$ref": "#/$defs/function" }]
              }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "cursor" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": { "oneOf": [{ "$ref": "#/$defs/cursor" }, { "$ref": "#/$defs/function" }] }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "shadow" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": { "oneOf": [{ "$ref": "#/$defs/shadow" }, { "$ref": "#/$defs/function" }] }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "gradient" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": {
                "oneOf": [{ "$ref": "#/$defs/gradient" }, { "$ref": "#/$defs/function" }]
              }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "filter" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": {
                "oneOf": [{ "$ref": "#/$defs/filter" }, { "$ref": "#/$defs/function" }]
              }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "opacity" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": { "oneOf": [{ "$ref": "#/$defs/opacity" }, { "$ref": "#/$defs/function" }] }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "duration" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": {
                "oneOf": [{ "$ref": "#/$defs/duration" }, { "$ref": "#/$defs/function" }]
              }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "easing" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": { "oneOf": [{ "$ref": "#/$defs/easing" }, { "$ref": "#/$defs/function" }] }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "z-index" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": { "oneOf": [{ "$ref": "#/$defs/z-index" }, { "$ref": "#/$defs/function" }] }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "motion" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": { "oneOf": [{ "$ref": "#/$defs/motion" }, { "$ref": "#/$defs/function" }] }
            }
          }
        },
        {
          "if": { "properties": { "$type": { "const": "elevation" } }, "required": ["$type"] },
          "then": {
            "properties": {
              "$value": {
                "oneOf": [{ "$ref": "#/$defs/elevation" }, { "$ref": "#/$defs/function" }]
              }
            }
          }
        },
        {
          "if": {
            "properties": { "$type": { "const": "component" } },
            "required": ["$type", "$value"]
          },
          "then": {
            "properties": {
              "$value": {
                "type": "object",
                "required": ["$slots"],
                "properties": {
                  "$slots": {
                    "type": "object",
                    "minProperties": 1,
                    "propertyNames": { "pattern": "^(?!\\$)" },
                    "patternProperties": {
                      "^(?!\\$)": {
                        "allOf": [
                          { "$ref": "#/$defs/token" },
                          {
                            "not": {
                              "properties": { "$type": { "const": "component" } },
                              "required": ["$type"]
                            }
                          }
                        ]
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "additionalProperties": true
              }
            }
          }
        }
      ]
    },
    "override": {
      "title": "Override rule",
      "description": "Contextual substitution entry evaluated against $when conditions per Theming and overrides §$overrides.",
      "$comment": "Theming and overrides §$overrides.",
      "allOf": [
        { "$ref": "#/$defs/override-core" },
        {
          "anyOf": [
            { "required": ["$ref"] },
            { "required": ["$value"] },
            { "required": ["$fallback"] }
          ],
          "$comment": "Override entries MUST declare $ref, $value, or $fallback.",
          "title": "Override resolution requirement"
        },
        {
          "if": { "required": ["$ref"] },
          "then": {
            "properties": { "$value": false },
            "$comment": "Entries using $ref MUST NOT also declare $value."
          }
        },
        {
          "if": { "required": ["$value"] },
          "then": {
            "properties": { "$ref": false },
            "$comment": "Entries using inline $value MUST NOT also declare $ref."
          }
        }
      ]
    },
    "fallback": {
      "title": "Fallback chain",
      "description": "Single fallback entry or ordered array evaluated when primary overrides fail per Theming and overrides §$overrides.",
      "$comment": "Theming and overrides §$overrides: $fallback MAY be a single entry or an array processed sequentially.",
      "oneOf": [
        { "$ref": "#/$defs/fallbackEntry" },
        {
          "type": "array",
          "minItems": 1,
          "items": { "$ref": "#/$defs/fallbackEntry" }
        }
      ]
    },
    "fallbackEntry": {
      "title": "Fallback entry",
      "description": "Single fallback candidate containing a $ref or inline $value per Theming and overrides §$overrides.",
      "$comment": "Theming and overrides §$overrides: fallback entries mirror override semantics.",
      "allOf": [
        { "$ref": "#/$defs/fallback-entry-core" },
        {
          "anyOf": [{ "required": ["$ref"] }, { "required": ["$value"] }],
          "$comment": "Fallback entries MUST declare either $ref or $value.",
          "title": "Fallback resolution requirement"
        },
        {
          "if": { "required": ["$ref"] },
          "then": {
            "properties": { "$value": false },
            "$comment": "Fallback entries using $ref MUST NOT also declare $value."
          }
        },
        {
          "if": { "required": ["$value"] },
          "then": {
            "properties": { "$ref": false },
            "$comment": "Fallback entries using inline $value MUST NOT also declare $ref."
          }
        }
      ]
    },
    "node": {
      "title": "Token or collection node",
      "description": "Tree node that is either a token or a collection per Architecture and model §tokens-and-collections.",
      "$comment": "Architecture and model §tokens-and-collections.",
      "oneOf": [{ "$ref": "#/$defs/token" }, { "$ref": "#/$defs/collection" }]
    },
    "collection": {
      "title": "Token collection",
      "description": "Object without $value whose non-reserved members are tokens or collections per Architecture and model §tokens-and-collections.",
      "$comment": "Architecture and model §tokens-and-collections.",
      "allOf": [
        { "$ref": "#/$defs/metadata-members" },
        {
          "type": "object",
          "patternProperties": {
            "^(?!\\$)": { "$ref": "#/$defs/node" },
            "^\\$": {}
          },
          "unevaluatedProperties": false,
          "allOf": [
            { "not": { "required": ["$value"] } },
            {
              "if": { "minProperties": 1 },
              "then": { "not": { "propertyNames": { "pattern": "^\\$" } } }
            }
          ]
        },
        { "$ref": "#/$defs/lifecycle-metadata" }
      ]
    },
    "token": {
      "title": "Design token",
      "description": "Object declaring either $value or $ref along with optional metadata per Terminology §token and Format and serialisation §$ref.",
      "$comment": "Terminology §token and Format and serialisation §$ref.",
      "allOf": [
        { "$ref": "#/$defs/metadata-members" },
        { "$ref": "#/$defs/token-core" },
        { "$ref": "#/$defs/lifecycle-metadata" }
      ]
    },
    "dimension": {
      "type": "object",
      "required": ["dimensionType", "value", "unit"],
      "properties": {
        "dimensionType": {
          "type": "string",
          "enum": ["length", "angle", "resolution", "custom"]
        },
        "value": { "type": "number" },
        "unit": { "type": "string" },
        "fontScale": {
          "type": "boolean",
          "description": "Whether the value scales with the user's font settings.",
          "$comment": "When true, MUST follow Dynamic Type (IOS-DYNAMIC-TYPE) and Android scale-independent behaviour (ANDROID-DP-SP)."
        }
      },
      "additionalProperties": false,
      "allOf": [
        {
          "if": {
            "properties": { "dimensionType": { "const": "length" } },
            "required": ["dimensionType"]
          },
          "then": {
            "properties": {
              "unit": {
                "type": "string",
                "pattern": "^(?:%|[A-Za-z][A-Za-z0-9-]*)$",
                "$comment": "MUST conform to CSS <length> or <percentage> (css-values-4) or native point/density-independent units (IOS-POINTS, ANDROID-DP-SP)."
              }
            }
          }
        },
        {
          "if": {
            "properties": { "dimensionType": { "const": "angle" } },
            "required": ["dimensionType"]
          },
          "then": {
            "properties": {
              "unit": {
                "type": "string",
                "pattern": "^[A-Za-z][A-Za-z0-9-]*$",
                "$comment": "MUST conform to CSS <angle> production (css-values-4)."
              }
            },
            "not": { "required": ["fontScale"] }
          }
        },
        {
          "if": {
            "properties": { "dimensionType": { "const": "resolution" } },
            "required": ["dimensionType"]
          },
          "then": {
            "properties": {
              "unit": {
                "type": "string",
                "pattern": "^[A-Za-z][A-Za-z0-9-]*$",
                "$comment": "MUST conform to CSS <resolution> production (css-values-4)."
              }
            },
            "not": { "required": ["fontScale"] }
          }
        },
        {
          "if": {
            "properties": { "dimensionType": { "const": "custom" } },
            "required": ["dimensionType"]
          },
          "then": {
            "properties": {
              "unit": {
                "type": "string",
                "pattern": "^[a-z0-9]+(?:\\.[a-z0-9-]+)+$"
              }
            },
            "not": { "required": ["fontScale"] }
          }
        }
      ]
    },
    "font-dimension": {
      "oneOf": [
        {
          "type": "object",
          "required": ["dimensionType", "value", "unit"],
          "properties": {
            "dimensionType": { "const": "length" },
            "value": { "type": "number" },
            "unit": {
              "type": "string",
              "pattern": "^(?:%|[A-Za-z][A-Za-z0-9-]*)$",
              "$comment": "MUST conform to CSS <length> or <percentage> (css-values-4) or native point/density-independent units (IOS-POINTS, ANDROID-DP-SP)."
            },
            "fontScale": {
              "type": "boolean",
              "description": "Whether the value scales with the user's font settings.",
              "$comment": "When true, MUST follow Dynamic Type (IOS-DYNAMIC-TYPE) and Android scale-independent behaviour (ANDROID-DP-SP)."
            }
          },
          "additionalProperties": false
        },
        { "$ref": "#/$defs/reference" }
      ]
    },
    "length-dimension": {
      "type": "object",
      "required": ["dimensionType", "value", "unit"],
      "properties": {
        "dimensionType": { "const": "length" },
        "value": { "type": "number" },
        "unit": {
          "type": "string",
          "pattern": "^(?:%|[A-Za-z][A-Za-z0-9-]*)$",
          "$comment": "MUST conform to CSS <length> or <percentage> (css-values-4) or native point/density-independent units (IOS-POINTS, ANDROID-DP-SP)."
        },
        "fontScale": {
          "type": "boolean",
          "description": "Whether the value scales with the user's font settings.",
          "$comment": "When true, MUST follow Dynamic Type (IOS-DYNAMIC-TYPE) and Android scale-independent behaviour (ANDROID-DP-SP)."
        }
      },
      "additionalProperties": false
    },
    "angle-dimension": {
      "type": "object",
      "required": ["dimensionType", "value", "unit"],
      "properties": {
        "dimensionType": { "const": "angle" },
        "value": { "type": "number" },
        "unit": {
          "type": "string",
          "pattern": "^[A-Za-z][A-Za-z0-9-]*$",
          "$comment": "MUST conform to CSS <angle> production (css-values-4)."
        }
      },
      "additionalProperties": false
    },
    "line-height": {
      "title": "Line height value",
      "description": "Unitless ratio or font-dimension measurement describing baseline spacing per Typography §line-height.",
      "$comment": "Typography §line-height: value MUST be a non-negative ratio or font-dimension measurement.",
      "oneOf": [
        {
          "type": "number",
          "minimum": 0,
          "description": "Ratio multiplied by fontSize to compute baseline-to-baseline distance."
        },
        {
          "allOf": [
            { "$ref": "#/$defs/font-dimension" },
            {
              "if": { "required": ["$ref"] },
              "then": {},
              "else": {
                "properties": {
                  "value": {
                    "type": "number",
                    "minimum": 0,
                    "description": "Non-negative font-dimension magnitude for line height measurements."
                  }
                }
              }
            }
          ]
        }
      ]
    },
    "color": {
      "type": "object",
      "required": ["colorSpace", "components"],
      "properties": {
        "colorSpace": {
          "$ref": "#/$defs/css-ident",
          "$comment": "MUST be a CSS <ident> naming a colour space defined by CSS Color 4 or registered via @color-profile (css-color-4)."
        },
        "components": {
          "type": "array",
          "minItems": 1,
          "items": { "type": "number" },
          "$comment": "Channel order, ranges, and optional alpha MUST follow CSS Color 4 for the referenced colour space (css-color-4)."
        },
        "hex": {
          "type": "string",
          "pattern": "^#(?:[0-9A-Fa-f]{3}|[0-9A-Fa-f]{4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$",
          "$comment": "Optional CSS hexadecimal colour serialization (css-color-4)."
        },
        "alpha": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "$comment": "Optional fallback alpha matching CSS <alpha-value> semantics (css-color-4)."
        }
      },
      "additionalProperties": false,
      "allOf": [
        {
          "if": { "required": ["alpha"] },
          "then": { "required": ["hex"] }
        },
        {
          "if": { "required": ["hex"] },
          "then": {
            "properties": {
              "colorSpace": {
                "const": "srgb",
                "$comment": "Hexadecimal strings serialize sRGB colours (css-color-4)."
              }
            }
          }
        }
      ]
    },
    "cursor": {
      "type": "object",
      "required": ["cursorType", "value"],
      "properties": {
        "cursorType": {
          "type": "string",
          "pattern": "^(?:css|ios|android)(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)+$",
          "$comment": "MUST identify pointer contexts defined by CSS cursor grammars, UIKit UIPointerStyle APIs, or Android PointerIcon classes (e.g. css.cursor, ios.uipointerstyle, android.pointer-icon)."
        },
        "value": {
          "oneOf": [
            {
              "type": "string",
              "minLength": 1,
              "$comment": "String values MUST conform to the CSS <cursor> production (css-ui-4#propdef-cursor) or name native pointer styles/icons published by UIPointerStyle and PointerIcon."
            },
            {
              "type": "object",
              "minProperties": 1,
              "$comment": "Object values MAY encode structured pointer metadata (for example UIPointerStyle.shape or PointerIcon hotspots) and MUST follow the platform APIs they reference.",
              "additionalProperties": true
            }
          ]
        },
        "parameters": {
          "type": "object",
          "additionalProperties": true,
          "$comment": "Optional parameters supply reusable inputs such as hotspot coordinates or referenced tokens consumed by pointer APIs."
        }
      },
      "additionalProperties": false
    },
    "font-weight-string": {
      "type": "string",
      "pattern": "^(?:[Bb][Oo][Ll][Dd][Ee][Rr]|[Ll][Ii][Gg][Hh][Tt][Ee][Rr]|(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\\+?(?:0*(?:[1-9]\\d{0,2})(?:\\.\\d+)?|0*1000(?:\\.0+)?))(?:\\s+(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\\+?(?:0*(?:[1-9]\\d{0,2})(?:\\.\\d+)?|0*1000(?:\\.0+)?)))?)$",
      "$comment": "String weights MUST conform to CSS <font-weight-absolute>, <font-weight-relative>, or <font-weight-range> productions (css-fonts-4)."
    },
    "font-style-string": {
      "type": "string",
      "pattern": "^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Ii][Tt][Aa][Ll][Ii][Cc]|[Oo][Bb][Ll][Ii][Qq][Uu][Ee](?:\\s+[-+]?(?:\\d+(?:\\.\\d+)?|\\.\\d+)(?:[Ee][+-]?\\d+)?(?:[Dd][Ee][Gg]|[Gg][Rr][Aa][Dd]|[Rr][Aa][Dd]|[Tt][Uu][Rr][Nn]))?)$",
      "$comment": "Font style keywords MUST match CSS font-style grammar, optionally supplying an oblique angle (css-fonts-4, css-values-4)."
    },
    "font-variant-string": {
      "type": "string",
      "pattern": "^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Nn][Oo][Nn][Ee]|(?:(?:[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Nn][Oo]-[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Uu][Nn][Ii][Cc][Aa][Ss][Ee]|[Tt][Ii][Tt][Ll][Ii][Nn][Gg]-[Cc][Aa][Pp][Ss]|[Ll][Ii][Nn][Ii][Nn][Gg]-[Nn][Uu][Mm][Ss]|[Oo][Ll][Dd][Ss][Tt][Yy][Ll][Ee]-[Nn][Uu][Mm][Ss]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Nn][Uu][Mm][Ss]|[Tt][Aa][Bb][Uu][Ll][Aa][Rr]-[Nn][Uu][Mm][Ss]|[Dd][Ii][Aa][Gg][Oo][Nn][Aa][Ll]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Ss][Tt][Aa][Cc][Kk][Ee][Dd]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Oo][Rr][Dd][Ii][Nn][Aa][Ll]|[Ss][Ll][Aa][Ss][Hh][Ee][Dd]-[Zz][Ee][Rr][Oo]|[Jj][Ii][Ss]78|[Jj][Ii][Ss]83|[Jj][Ii][Ss]90|[Jj][Ii][Ss]04|[Ss][Ii][Mm][Pp][Ll][Ii][Ff][Ii][Ee][Dd]|[Tt][Rr][Aa][Dd][Ii][Tt][Ii][Oo][Nn][Aa][Ll]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Rr][Uu][Bb][Yy]|[Ss][Uu][Bb]|[Ss][Uu][Pp][Ee][Rr]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ff][Oo][Rr][Mm][Ss]|[Ss][Tt][Yy][Ll][Ii][Ss][Tt][Ii][Cc]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\\s*\\)|[Ss][Tt][Yy][Ll][Ee][Ss][Ee][Tt]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\\s*,\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\\s*\\)|[Cc][Hh][Aa][Rr][Aa][Cc][Tt][Ee][Rr]-[Vv][Aa][Rr][Ii][Aa][Nn][Tt]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\\s*,\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\\s*\\)|[Ss][Ww][Aa][Ss][Hh]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\\s*\\)|[Oo][Rr][Nn][Aa][Mm][Ee][Nn][Tt][Ss]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\\s*\\)|[Aa][Nn][Nn][Oo][Tt][Aa][Tt][Ii][Oo][Nn]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\\s*,\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\\s*\\))(?:\\s+(?:[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Nn][Oo]-[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Uu][Nn][Ii][Cc][Aa][Ss][Ee]|[Tt][Ii][Tt][Ll][Ii][Nn][Gg]-[Cc][Aa][Pp][Ss]|[Ll][Ii][Nn][Ii][Nn][Gg]-[Nn][Uu][Mm][Ss]|[Oo][Ll][Dd][Ss][Tt][Yy][Ll][Ee]-[Nn][Uu][Mm][Ss]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Nn][Uu][Mm][Ss]|[Tt][Aa][Bb][Uu][Ll][Aa][Rr]-[Nn][Uu][Mm][Ss]|[Dd][Ii][Aa][Gg][Oo][Nn][Aa][Ll]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Ss][Tt][Aa][Cc][Kk][Ee][Dd]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Oo][Rr][Dd][Ii][Nn][Aa][Ll]|[Ss][Ll][Aa][Ss][Hh][Ee][Dd]-[Zz][Ee][Rr][Oo]|[Jj][Ii][Ss]78|[Jj][Ii][Ss]83|[Jj][Ii][Ss]90|[Jj][Ii][Ss]04|[Ss][Ii][Mm][Pp][Ll][Ii][Ff][Ii][Ee][Dd]|[Tt][Rr][Aa][Dd][Ii][Tt][Ii][Oo][Nn][Aa][Ll]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Rr][Uu][Bb][Yy]|[Ss][Uu][Bb]|[Ss][Uu][Pp][Ee][Rr]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ff][Oo][Rr][Mm][Ss]|[Ss][Tt][Yy][Ll][Ii][Ss][Tt][Ii][Cc]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\\s*\\)|[Ss][Tt][Yy][Ll][Ee][Ss][Ee][Tt]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\\s*,\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\\s*\\)|[Cc][Hh][Aa][Rr][Aa][Cc][Tt][Ee][Rr]-[Vv][Aa][Rr][Ii][Aa][Nn][Tt]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\\s*,\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\\s*\\)|[Ss][Ww][Aa][Ss][Hh]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\\s*\\)|[Oo][Rr][Nn][Aa][Mm][Ee][Nn][Tt][Ss]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\\s*\\)|[Aa][Nn][Nn][Oo][Tt][Aa][Tt][Ii][Oo][Nn]\\(\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\\s*,\\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\\s*\\)))*))$",
      "$comment": "Font variant sequences MUST match CSS font-variant grammar (css-fonts-4)."
    },
    "font-stretch-string": {
      "type": "string",
      "pattern": "^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|(?:[Uu][Ll][Tt][Rr][Aa]|[Ee][Xx][Tt][Rr][Aa]|[Ss][Ee][Mm][Ii])-[Cc][Oo][Nn][Dd][Ee][Nn][Ss][Ee][Dd]|[Cc][Oo][Nn][Dd][Ee][Nn][Ss][Ee][Dd]|(?:[Ss][Ee][Mm][Ii]|[Ee][Xx][Tt][Rr][Aa]|[Uu][Ll][Tt][Rr][Aa])-[Ee][Xx][Pp][Aa][Nn][Dd][Ee][Dd]|[Ee][Xx][Pp][Aa][Nn][Dd][Ee][Dd]|\\+?(?:0*(?:[1-9]\\d{0,2})(?:\\.\\d+)?|0*1000(?:\\.0+)?)%)$",
      "$comment": "Font stretch values MUST match CSS <font-stretch-absolute> grammar (css-fonts-4)."
    },
    "font": {
      "type": "object",
      "required": ["fontType", "family"],
      "properties": {
        "fontType": {
          "type": "string",
          "pattern": "^(?:css|ios|android)(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)+$",
          "$comment": "MUST identify platform context and asset source using dot-separated identifiers aligned with CSS Fonts src descriptors, UIKit UIFont APIs, or Android font resource/typeface loaders."
        },
        "family": {
          "type": "string",
          "$comment": "MUST identify a family using CSS <family-name> grammar (css-fonts-4) or platform catalog registrations (IOS-FONT-CATALOG, ANDROID-FONT-FAMILY)."
        },
        "fallbacks": {
          "type": "array",
          "minItems": 1,
          "items": { "$ref": "#/$defs/trimmedString" },
          "$comment": "Fallback stacks MUST preserve order and reuse CSS <family-name> grammar and generic family keywords (css-fonts-4) so they align with platform catalog registrations (IOS-FONT-CATALOG, ANDROID-FONT-FAMILY)."
        },
        "style": {
          "$ref": "#/$defs/font-style-string",
          "$comment": "MUST conform to CSS <font-style-absolute> grammar (css-fonts-4); angles MUST follow <angle> (css-values-4)."
        },
        "weight": {
          "oneOf": [
            {
              "type": "number",
              "minimum": 1,
              "maximum": 1000,
              "$comment": "Numeric weights MUST follow the 1..1000 range defined by CSS Fonts (css-fonts-4)."
            },
            { "$ref": "#/$defs/font-weight-string" }
          ]
        }
      },
      "additionalProperties": false
    },
    "fontFace": {
      "type": "object",
      "required": ["src", "fontFamily"],
      "properties": {
        "src": {
          "type": "array",
          "minItems": 1,
          "$comment": "Entries MUST correspond to CSS @font-face src descriptors (css-fonts-4) and map to bundled/downloadable font resources registered through iOS font catalogs and Android font resources (IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).",
          "items": {
            "oneOf": [
              {
                "type": "object",
                "required": ["url"],
                "properties": {
                  "url": {
                    "type": "string",
                    "$comment": "Font URLs MUST resolve to resources used by CSS url() and native registration APIs (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY)."
                  },
                  "format": {
                    "oneOf": [
                      { "type": "string" },
                      {
                        "type": "array",
                        "minItems": 1,
                        "items": { "type": "string" }
                      }
                    ],
                    "$comment": "Font format hints MUST match CSS src format() descriptors (css-fonts-4)."
                  },
                  "tech": {
                    "type": "array",
                    "minItems": 1,
                    "items": { "type": "string" },
                    "$comment": "Technology hints MUST align with CSS src tech() identifiers (css-fonts-4#font-tech-values)."
                  }
                },
                "additionalProperties": false
              },
              {
                "type": "object",
                "required": ["local"],
                "properties": {
                  "local": {
                    "type": "string",
                    "$comment": "Local font references MUST match CSS src local() <family-name> grammar and platform catalog registrations (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY)."
                  }
                },
                "additionalProperties": false
              }
            ]
          }
        },
        "fontFamily": {
          "type": "string",
          "$comment": "MUST identify a family using CSS <family-name> grammar (css-fonts-4) or platform catalog registrations (IOS-FONT-CATALOG, ANDROID-FONT-FAMILY)."
        },
        "fontWeight": {
          "oneOf": [
            {
              "type": "number",
              "minimum": 1,
              "maximum": 1000,
              "$comment": "Numeric weights MUST follow the 1..1000 range defined by CSS Fonts (css-fonts-4)."
            },
            { "$ref": "#/$defs/font-weight-string" }
          ]
        },
        "fontStyle": {
          "$ref": "#/$defs/font-style-string",
          "$comment": "MUST conform to CSS font-style descriptor grammar (css-fonts-4); oblique angles map to the slnt variation axis per UIFontDescriptor.AttributeName.variations and Typeface.Builder#setFontVariationSettings (IOS-FONT-VARIATIONS, ANDROID-FONT-VARIATION)."
        },
        "fontStretch": {
          "$ref": "#/$defs/font-stretch-string",
          "$comment": "Stretch keywords MUST follow CSS <font-stretch-absolute> grammar (css-fonts-4)."
        },
        "unicodeRange": {
          "type": "string",
          "pattern": "^(?:U\\+[0-9A-F?]{1,6}(?:-[0-9A-F?]{1,6})?)(?:\\s*,\\s*U\\+[0-9A-F?]{1,6}(?:-[0-9A-F?]{1,6})?)*$",
          "$comment": "Ranges MUST conform to the CSS unicode-range descriptor grammar (css-fonts-4)."
        },
        "fontDisplay": {
          "type": "string",
          "pattern": "^(?:[Aa][Uu][Tt][Oo]|[Bb][Ll][Oo][Cc][Kk]|[Ss][Ww][Aa][Pp]|[Ff][Aa][Ll][Ll][Bb][Aa][Cc][Kk]|[Oo][Pp][Tt][Ii][Oo][Nn][Aa][Ll])$",
          "$comment": "Display strategy MUST use the css-fonts-4 font-display keywords; native runtimes map these hints to preload/async policies."
        }
      },
      "additionalProperties": false
    },
    "typography": {
      "type": "object",
      "required": ["fontFamily", "fontSize"],
      "properties": {
        "typographyType": {
          "type": "string",
          "pattern": "^[a-zA-Z][\\w-]*$",
          "description": "Canonical values such as 'body', 'heading', and 'caption' are registered. Custom values matching this pattern MAY be used; consumers MUST ignore unrecognised types to preserve compatibility."
        },
        "fontFamily": {
          "oneOf": [{ "type": "string" }, { "$ref": "#/$defs/reference" }]
        },
        "fontSize": { "$ref": "#/$defs/fontDimensionReference" },
        "lineHeight": {
          "description": "Baseline-to-baseline distance as a ratio or font-dimension.",
          "allOf": [{ "$ref": "#/$defs/line-height" }]
        },
        "letterSpacing": {
          "$comment": "MUST follow CSS letter-spacing grammar and reuse font-dimension unit conversions.",
          "oneOf": [
            { "$ref": "#/$defs/fontDimensionReference" },
            {
              "type": "string",
              "enum": ["normal"],
              "$comment": "MUST be the keyword 'normal' per CSS Text Module Level 3 letter-spacing grammar."
            }
          ]
        },
        "wordSpacing": {
          "$comment": "MUST conform to CSS word-spacing <length-percentage> grammar and platform unit semantics.",
          "oneOf": [
            { "$ref": "#/$defs/fontDimensionReference" },
            {
              "type": "string",
              "enum": ["normal"],
              "$comment": "MUST be the keyword 'normal' per CSS Text Module Level 3 word-spacing grammar."
            }
          ]
        },
        "fontWeight": {
          "$comment": "MUST match CSS font-weight absolute or relative productions and map to platform weight APIs.",
          "oneOf": [
            {
              "type": "number",
              "minimum": 1,
              "maximum": 1000,
              "$comment": "MUST be within the CSS absolute weight range of 1-1000 and MAY include fractional values for variable fonts."
            },
            { "$ref": "#/$defs/font-weight-string" }
          ]
        },
        "fontStyle": {
          "$ref": "#/$defs/font-style-string",
          "$comment": "MUST conform to CSS font-style grammar and map to native italic traits or the slnt variation axis (css-fonts-4, IOS-FONT-TRAITS, IOS-FONT-VARIATIONS, ANDROID-FONT-SLANT, ANDROID-FONT-VARIATION)."
        },
        "fontVariant": {
          "$ref": "#/$defs/font-variant-string",
          "$comment": "MUST match the CSS font-variant grammar when present."
        },
        "fontStretch": {
          "$ref": "#/$defs/font-stretch-string",
          "$comment": "MUST match the CSS font-stretch grammar when present."
        },
        "textDecoration": {
          "type": "string",
          "$comment": "MUST encode the CSS text-decoration shorthand and associated line/style/thickness grammar."
        },
        "textTransform": {
          "type": "string",
          "$comment": "MUST conform to the CSS text-transform list grammar and preserve locale-sensitive casing."
        },
        "color": { "$ref": "#/$defs/colorReference" },
        "fontFeatures": {
          "type": "array",
          "$comment": "MUST contain OpenType feature tags per CSS font-feature-settings and the OpenType registry.",
          "items": {
            "type": "string",
            "pattern": "^[A-Za-z0-9]{4}$",
            "$comment": "MUST be a four-character OpenType feature tag registered by CSS font-feature-settings or documented by the font."
          }
        },
        "underlineThickness": { "$ref": "#/$defs/fontDimensionReference" },
        "underlineOffset": { "$ref": "#/$defs/fontDimensionReference" },
        "overlineThickness": { "$ref": "#/$defs/fontDimensionReference" },
        "overlineOffset": { "$ref": "#/$defs/fontDimensionReference" }
      },
      "additionalProperties": true
    },
    "borderCornerRadius": {
      "anyOf": [
        {
          "$ref": "#/$defs/dimensionReference",
          "$comment": "Single value MUST follow the <length-percentage> grammar defined for CSS border-radius."
        },
        {
          "type": "object",
          "required": ["x"],
          "properties": {
            "x": {
              "$ref": "#/$defs/dimensionReference",
              "$comment": "Horizontal radius MUST conform to CSS <length-percentage> and native point/density semantics."
            },
            "y": {
              "$ref": "#/$defs/dimensionReference",
              "$comment": "Optional vertical radius MUST conform to CSS <length-percentage>; when omitted, consumers reuse the horizontal value."
            }
          },
          "additionalProperties": false,
          "$comment": "Encodes the <length-percentage>{1,2} grammar used by border-top-left-radius and related properties."
        }
      ]
    },
    "border": {
      "type": "object",
      "required": ["borderType", "width", "style", "color"],
      "properties": {
        "borderType": {
          "type": "string",
          "pattern": "^(?:css|ios|android)(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)+$",
          "$comment": "MUST identify CSS border/outline contexts or native stroke APIs such as CALayer and GradientDrawable."
        },
        "width": {
          "oneOf": [
            { "$ref": "#/$defs/dimensionReference" },
            {
              "type": "string",
              "enum": ["thin", "medium", "thick"]
            }
          ],
          "$comment": "Width MUST follow the <line-width> grammar, accepting CSS keywords or dimension values that respect point/density conversions for pt, dp, and sp units."
        },
        "style": {
          "type": "string",
          "pattern": "^[a-z-]+$",
          "$comment": "MUST match CSS <line-style> keywords; native implementations map them to dash patterns or fall back to solid."
        },
        "strokeStyle": {
          "oneOf": [{ "$ref": "#/$defs/strokeStyle" }, { "$ref": "#/$defs/reference" }],
          "$comment": "Optional strokeStyle metadata MUST capture dash, cap, and join semantics compatible with CSS border-image, SVG stroke, CAShapeLayer.lineDashPattern, and Android Paint#setPathEffect."
        },
        "color": {
          "$ref": "#/$defs/colorReference",
          "$comment": "Border colour MUST conform to CSS <color> values and convert to CGColor or Android colour integers."
        },
        "radius": {
          "anyOf": [
            {
              "$ref": "#/$defs/dimensionReference",
              "$comment": "Uniform radius MUST follow the border-radius <length-percentage> grammar."
            },
            {
              "type": "object",
              "minProperties": 1,
              "properties": {
                "topLeft": { "$ref": "#/$defs/borderCornerRadius" },
                "topRight": { "$ref": "#/$defs/borderCornerRadius" },
                "bottomRight": { "$ref": "#/$defs/borderCornerRadius" },
                "bottomLeft": { "$ref": "#/$defs/borderCornerRadius" },
                "topStart": { "$ref": "#/$defs/borderCornerRadius" },
                "topEnd": { "$ref": "#/$defs/borderCornerRadius" },
                "bottomStart": { "$ref": "#/$defs/borderCornerRadius" },
                "bottomEnd": { "$ref": "#/$defs/borderCornerRadius" }
              },
              "additionalProperties": false,
              "$comment": "Per-corner entries MUST follow border-radius semantics with names matching physical or logical corners."
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "strokeStyle": {
      "type": "object",
      "minProperties": 1,
      "properties": {
        "dashArray": {
          "type": "array",
          "minItems": 1,
          "items": {
            "oneOf": [
              {
                "type": "number",
                "minimum": 0,
                "$comment": "Numeric dash intervals MUST follow the <number> grammar used by SVG stroke-dasharray and CanvasRenderingContext2D.setLineDash."
              },
              {
                "$ref": "#/$defs/lengthDimensionReference",
                "$comment": "Length dash intervals MUST conform to the <length> production accepted by SVG stroke-dasharray and CSS border-image repeat lengths."
              }
            ]
          },
          "$comment": "Sequence of dash and gap lengths MUST follow SVG stroke-dasharray semantics and map to CAShapeLayer.lineDashPattern and Android DashPathEffect intervals."
        },
        "dashOffset": {
          "oneOf": [
            {
              "type": "number",
              "$comment": "Numeric offsets MUST follow the <number> grammar from SVG stroke-dashoffset representing multiples of the stroke width."
            },
            {
              "$ref": "#/$defs/lengthDimensionReference",
              "$comment": "Length offsets MUST conform to CSS <length> semantics for stroke-dashoffset and native stroke APIs."
            }
          ]
        },
        "lineCap": {
          "type": "string",
          "enum": ["butt", "round", "square"],
          "$comment": "Line caps MUST match the <stroke-linecap> keywords butt, round, or square defined by SVG and Canvas 2D."
        },
        "lineJoin": {
          "type": "string",
          "enum": ["miter", "round", "bevel"],
          "$comment": "Line joins MUST match the <stroke-linejoin> keywords miter, round, or bevel defined by SVG and Canvas 2D."
        },
        "miterLimit": {
          "type": "number",
          "minimum": 1,
          "$comment": "Miter limits MUST be >= 1 following SVG stroke-miterlimit and CanvasRenderingContext2D.miterLimit semantics."
        }
      },
      "additionalProperties": false
    },
    "shadow": {
      "oneOf": [
        { "$ref": "#/$defs/shadow-layer" },
        {
          "type": "array",
          "minItems": 1,
          "items": { "$ref": "#/$defs/shadow-layer" }
        }
      ]
    },
    "shadow-layer": {
      "type": "object",
      "required": ["shadowType", "offsetX", "offsetY", "blur", "color"],
      "properties": {
        "shadowType": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*(?:\\.[a-z0-9-]+)*$",
          "$comment": "MUST identify the rendering context defined by CSS <shadow> grammars, UIKit CALayer/NSShadow APIs, or Android View/Paint shadow documentation (e.g. css.box-shadow, css.text-shadow, css.filter.drop-shadow, ios.layer, ios.text, android.view.elevation)."
        },
        "offsetX": {
          "$ref": "#/$defs/lengthDimensionReference",
          "$comment": "Horizontal offset MUST conform to CSS <length> or platform-native units such as points (pt) and density-independent pixels (dp)."
        },
        "offsetY": {
          "$ref": "#/$defs/lengthDimensionReference",
          "$comment": "Vertical offset MUST conform to CSS <length> or platform-native units such as points (pt) and density-independent pixels (dp)."
        },
        "blur": {
          "$ref": "#/$defs/lengthDimensionReference",
          "$comment": "Blur radius MUST match the <length> position in the CSS <shadow> production or equivalent CALayer.shadowRadius / Paint#setShadowLayer radius semantics."
        },
        "spread": {
          "$ref": "#/$defs/lengthDimensionReference",
          "$comment": "Optional spread MUST follow the final <length> of CSS <shadow> and is realised via CALayer.shadowPath or Android outline inflation."
        },
        "color": {
          "$ref": "#/$defs/colorReference",
          "$comment": "Shadow colour MUST conform to CSS <color> values and map to CGColor / Android colour integers."
        }
      },
      "additionalProperties": false
    },
    "color-stop-length-string": {
      "type": "string",
      "pattern": "^(?:(?:calc|min|max|clamp)\\([^]*\\)|[+-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+-]?\\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[+-]?(?:0+(?:\\.0+)?|\\.0+))(?:\\s+(?:(?:calc|min|max|clamp)\\([^]*\\)|[+-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+-]?\\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[+-]?(?:0+(?:\\.0+)?|\\.0+)))?$",
      "$comment": "Each token MUST be a CSS <length-percentage> or calc-style expression resolving to <length-percentage> (css-values-4, css-images-4)."
    },
    "gradient": {
      "type": "object",
      "required": ["gradientType", "stops"],
      "properties": {
        "gradientType": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*(?:\\.[a-z0-9-]+)*$",
          "$comment": "MUST correspond to gradient function identifiers defined in CSS Images Module Level 4 or platform equivalents such as CAGradientLayer.type and Android shader classes."
        },
        "stops": {
          "type": "array",
          "minItems": 2,
          "items": {
            "type": "object",
            "required": ["position", "color"],
            "properties": {
              "position": {
                "anyOf": [
                  {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "$comment": "Normalised offsets align with CAGradientLayer.locations and Android shader stop arrays."
                  },
                  { "$ref": "#/$defs/color-stop-length-string" }
                ]
              },
              "hint": {
                "anyOf": [
                  {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "$comment": "Normalised hints map to native midpoint interpolation controls."
                  },
                  {
                    "$ref": "#/$defs/color-stop-length-string",
                    "$comment": "MUST conform to the <color-hint> productions described in CSS Images Module Level 4."
                  }
                ]
              },
              "color": { "$ref": "#/$defs/colorReference" }
            },
            "additionalProperties": false
          },
          "$comment": "Represents the CSS <color-stop-list> grammar and corresponding native stop arrays."
        },
        "angle": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "\\S",
              "$comment": "MUST conform to the linear-gradient line syntax using CSS <angle> or <side-or-corner> tokens."
            },
            {
              "type": "number",
              "$comment": "Represents native rotation values interpreted in degrees when numeric."
            }
          ]
        },
        "center": {
          "anyOf": [
            {
              "type": "object",
              "required": ["x", "y"],
              "properties": {
                "x": { "type": "number", "minimum": 0, "maximum": 1 },
                "y": { "type": "number", "minimum": 0, "maximum": 1 }
              },
              "additionalProperties": false,
              "$comment": "Unit-square coordinates map to CAGradientLayer start/end points and Android radial or conic gradient centres."
            },
            {
              "type": "string",
              "pattern": "\\S",
              "$comment": "MUST conform to the CSS <position> production for radial and conic gradients."
            }
          ]
        },
        "shape": {
          "type": "string",
          "pattern": "\\S",
          "$comment": "MUST match <rg-ending-shape> keywords defined for radial-gradient() in CSS Images Module Level 3."
        }
      },
      "additionalProperties": false,
      "allOf": [
        {
          "if": { "properties": { "angle": {} }, "required": ["angle"] },
          "then": {
            "properties": {
              "gradientType": {
                "not": { "const": "radial" },
                "$comment": "Radial gradients do not accept an initial angle per CSS Images Module Level 4."
              }
            }
          }
        },
        {
          "if": { "properties": { "center": {} }, "required": ["center"] },
          "then": {
            "properties": {
              "gradientType": {
                "enum": ["radial", "conic"],
                "$comment": "Only radial-gradient() and conic-gradient() accept a centre position in CSS Images Module Level 4."
              }
            }
          }
        },
        {
          "if": { "properties": { "shape": {} }, "required": ["shape"] },
          "then": {
            "properties": {
              "gradientType": {
                "const": "radial",
                "$comment": "<rg-ending-shape> keywords are valid exclusively on radial-gradient() per CSS Images Module Level 3."
              }
            }
          }
        }
      ]
    },
    "filter": {
      "type": "object",
      "required": ["filterType", "operations"],
      "properties": {
        "filterType": {
          "type": "string",
          "pattern": "^(?:css|ios|android)(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)+$",
          "$comment": "MUST identify the rendering context defined by CSS filter(), Core Image CIFilter pipelines, or Android RenderEffect chains (for example css.filter, ios.cifilter, android.render-effect)."
        },
        "operations": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "required": ["fn"],
            "properties": {
              "fn": {
                "type": "string",
                "pattern": "^[a-z][a-z0-9-]*(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)*$",
                "$comment": "MUST reference a filter function from CSS Filter Effects Module Level 1 or its native analogue (for example blur, brightness, drop-shadow)."
              },
              "parameters": {
                "type": "array",
                "items": { "$ref": "#/$defs/function-parameter" },
                "default": [],
                "$comment": "Arguments MUST satisfy the grammar of the referenced filter function (e.g. CSS blur() <length>, brightness() numbers, drop-shadow() <shadow>) and map to CIFilter / RenderEffect parameters."
              }
            },
            "additionalProperties": false
          },
          "$comment": "Represents the ordered <filter-function-list> grammar from CSS Filter Effects."
        }
      },
      "additionalProperties": false
    },
    "opacity": {
      "type": "object",
      "required": ["opacityType", "value"],
      "properties": {
        "opacityType": {
          "type": "string",
          "pattern": "^(?:css|ios|android)(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)+$",
          "$comment": "MUST name a platform opacity property such as css.opacity (css-color-4#propdef-opacity), ios.uiview.alpha (IOS-UIVIEW-ALPHA), ios.layer.opacity (IOS-CALAYER), or android.view.alpha (ANDROID-VIEW-ALPHA)."
        },
        "value": {
          "oneOf": [
            {
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "$comment": "Numeric form MUST satisfy the <alpha-value> range defined by CSS Color Module Level 4 (css-color-4#typedef-alpha-value), UIView.alpha (IOS-UIVIEW-ALPHA), and View#setAlpha (ANDROID-VIEW-ALPHA)."
            },
            {
              "type": "string",
              "pattern": "^(?:[-+]?(?:\\d+(?:\\.\\d+)?|\\.\\d+)%?|[A-Za-z-]+\\(.+\\))$",
              "$comment": "String form MUST conform to the CSS <alpha-value> production (css-color-4#typedef-alpha-value)."
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "durationTimeUnit": {
      "type": "string",
      "enum": ["s", "ms"],
      "$comment": "MUST use CSS <time> units serialised as s or ms for transition and animation timing APIs (css-values-4#time-value, css-transitions-2, css-animations-2, IOS-CAANIMATION, ANDROID-VALUE-ANIMATOR)."
    },
    "durationFrameCountUnit": {
      "type": "string",
      "enum": ["frames"],
      "$comment": "MUST use the frame count keyword defined by CADisplayLink and Choreographer timing APIs (IOS-CADISPLAYLINK, ANDROID-CHOREOGRAPHER)."
    },
    "durationFractionUnit": {
      "type": "string",
      "enum": ["%"],
      "$comment": "MUST use CSS <percentage> serialisation for fraction/progress timelines (css-values-4#percentages, IOS-UIVIEWPROPERTYANIMATOR, ANDROID-OBJECTANIMATOR)."
    },
    "duration": {
      "type": "object",
      "required": ["durationType", "value", "unit"],
      "properties": {
        "durationType": {
          "type": "string",
          "pattern": "^(?:css|ios|android)(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)+$",
          "$comment": "MUST identify a duration context defined by CSS Transitions/Animations, Core Animation, UIViewPropertyAnimator, or Android animator APIs (for example css.transition-duration, ios.caanimation.duration, android.value-animator.duration, ios.cadisplaylink.frame-count)."
        },
        "value": { "type": "number" },
        "unit": {
          "type": "string",
          "$comment": "MUST serialise the unit token defined by the referenced duration grammar (css-values-4#time-value, css-values-4#percentages, IOS-CADISPLAYLINK, ANDROID-CHOREOGRAPHER)."
        }
      },
      "additionalProperties": false,
      "allOf": [
        {
          "if": {
            "properties": {
              "durationType": {
                "pattern": "^(?:css\\.(?:transition|animation)-duration|ios\\.caanimation\\.duration|android\\.value-animator\\.duration)$"
              }
            },
            "required": ["durationType"]
          },
          "then": {
            "$comment": "Duration contexts MUST encode non-negative CSS <time> values as defined by CSS Values & Units, Core Animation, and Android animator APIs (css-values-4#time-value, css-transitions-2, css-animations-2, IOS-CAANIMATION, ANDROID-VALUE-ANIMATOR).",
            "properties": {
              "value": {
                "type": "number",
                "minimum": 0,
                "$comment": "Non-negative durations matching the CSS <time> production."
              },
              "unit": { "$ref": "#/$defs/durationTimeUnit" }
            }
          }
        },
        {
          "if": {
            "properties": {
              "durationType": {
                "pattern": "^(?:ios\\.cadisplaylink\\.frame-count|android\\.choreographer\\.frame-count)$"
              }
            },
            "required": ["durationType"]
          },
          "then": {
            "$comment": "Frame-count durations carry platform refresh steps as described by CADisplayLink and Choreographer (IOS-CADISPLAYLINK, ANDROID-CHOREOGRAPHER).",
            "properties": {
              "value": {
                "type": "integer",
                "minimum": 0,
                "$comment": "Non-negative integer frame counts from the referenced timing API."
              },
              "unit": { "$ref": "#/$defs/durationFrameCountUnit" }
            }
          }
        },
        {
          "if": {
            "properties": {
              "durationType": {
                "pattern": "^(?:css\\.timeline\\.progress|ios\\.uianimation\\.fraction|android\\.animator-set\\.fraction)$"
              }
            },
            "required": ["durationType"]
          },
          "then": {
            "$comment": "Fraction/progress contexts serialise CSS <percentage> values used by timelines and native animation fractions (css-values-4#percentages, IOS-UIVIEWPROPERTYANIMATOR, ANDROID-OBJECTANIMATOR).",
            "properties": {
              "value": {
                "type": "number",
                "$comment": "Numeric percentage matching the CSS <percentage> grammar."
              },
              "unit": { "$ref": "#/$defs/durationFractionUnit" }
            }
          }
        }
      ]
    },
    "easing": {
      "type": "object",
      "required": ["easingFunction"],
      "properties": {
        "easingFunction": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)*$",
          "$comment": "MUST name a CSS <single-easing-function> production or a documented native analogue."
        },
        "parameters": {
          "type": "array",
          "items": {
            "anyOf": [{ "type": "number" }, { "type": "string" }]
          },
          "default": [],
          "$comment": "When present, MUST satisfy the argument grammar defined for the referenced easing function in CSS Easing Functions or platform timing APIs."
        }
      },
      "additionalProperties": false
    },
    "z-index": {
      "type": "object",
      "required": ["zIndexType", "value"],
      "properties": {
        "zIndexType": {
          "type": "string",
          "pattern": "^(?:css|ios|android)(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)+$",
          "$comment": "MUST name a stacking context primitive such as css.z-index, ios.calayer.z-position, android.view.z, or android.view.translationz as defined by CSS Positioned Layout Module Level 3 (css-position-3#propdef-z-index), CALayer.zPosition (IOS-CALAYER), and Android View Z APIs (ANDROID-VIEW-SETZ, ANDROID-VIEW-TRANSLATIONZ)."
        },
        "value": {
          "type": "number",
          "$comment": "MUST conform to CSS <integer> (css-position-3#propdef-z-index, css-values-4#integer-value), CALayer.zPosition (IOS-CALAYER), or Android View Z APIs (ANDROID-VIEW-SETZ, ANDROID-VIEW-TRANSLATIONZ) depending on the referenced platform."
        }
      },
      "additionalProperties": false,
      "allOf": [
        {
          "if": {
            "properties": { "zIndexType": { "pattern": "^css\\." } },
            "required": ["zIndexType"]
          },
          "then": {
            "properties": {
              "value": {
                "type": "integer",
                "$comment": "CSS z-index values MUST be integers per css-position-3#propdef-z-index."
              }
            }
          }
        }
      ]
    },
    "motion": {
      "type": "object",
      "required": ["motionType", "parameters"],
      "properties": {
        "motionType": {
          "type": "string",
          "pattern": "^(?:css|ios|android)(?:\\.[a-z0-9]+(?:-[a-z0-9]+)*)+$",
          "$comment": "MUST name a platform transform such as css.translate, ios.catransform3d.rotate, or android.viewpropertyanimator.scalex as defined by CSS Transforms Module Level 2 (css-transforms-2#transform-functions), Core Animation (IOS-CGAFFINETRANSFORM, IOS-CATRANSFORM3D, IOS-CAKEYFRAMEANIMATION), and Android animation APIs (ANDROID-VIEWPROPERTYANIMATOR, ANDROID-OBJECTANIMATOR)."
        },
        "parameters": {
          "type": "object",
          "$comment": "Members MUST align with the grammar of the referenced transform function."
        }
      },
      "additionalProperties": false,
      "allOf": [
        {
          "if": {
            "properties": {
              "motionType": {
                "pattern": "\\.(?:translate(?:[-a-z0-9]*)?|translation(?:[-a-z0-9]*)?)$"
              }
            },
            "required": ["motionType"]
          },
          "then": {
            "properties": {
              "parameters": { "$ref": "#/$defs/motion-translation" }
            }
          }
        },
        {
          "if": {
            "properties": {
              "motionType": {
                "pattern": "\\.(?:rotate(?:[-a-z0-9]*)?|rotation(?:[-a-z0-9]*)?)$"
              }
            },
            "required": ["motionType"]
          },
          "then": {
            "properties": {
              "parameters": { "$ref": "#/$defs/motion-rotation" }
            }
          }
        },
        {
          "if": {
            "properties": {
              "motionType": { "pattern": "\\.(?:scale(?:[-a-z0-9]*)?)$" }
            },
            "required": ["motionType"]
          },
          "then": {
            "properties": {
              "parameters": { "$ref": "#/$defs/motion-scale" }
            }
          }
        },
        {
          "if": {
            "properties": {
              "motionType": { "pattern": "\\.(?:path|offset-path|motion-path)$" }
            },
            "required": ["motionType"]
          },
          "then": {
            "properties": {
              "parameters": { "$ref": "#/$defs/motion-path" }
            }
          }
        }
      ]
    },
    "motion-length": {
      "oneOf": [{ "$ref": "#/$defs/lengthDimensionReference" }, { "$ref": "#/$defs/function" }],
      "$comment": "MUST evaluate to a CSS <length-percentage> (css-values-4#typedef-length-percentage) or equivalent platform distance for translation and path coordinates."
    },
    "motion-angle": {
      "oneOf": [{ "$ref": "#/$defs/angleDimensionReference" }, { "$ref": "#/$defs/function" }],
      "$comment": "MUST evaluate to a CSS <angle> (css-values-4#angles) compatible with Core Animation and Android rotation APIs."
    },
    "motion-translation": {
      "type": "object",
      "properties": {
        "x": { "$ref": "#/$defs/motion-length" },
        "y": { "$ref": "#/$defs/motion-length" },
        "z": { "$ref": "#/$defs/motion-length" }
      },
      "additionalProperties": false,
      "anyOf": [{ "required": ["x"] }, { "required": ["y"] }, { "required": ["z"] }]
    },
    "motion-origin": {
      "type": "object",
      "properties": {
        "x": { "type": "number", "minimum": 0, "maximum": 1 },
        "y": { "type": "number", "minimum": 0, "maximum": 1 },
        "z": { "type": "number", "minimum": 0, "maximum": 1 }
      },
      "additionalProperties": false,
      "anyOf": [{ "required": ["x"] }, { "required": ["y"] }, { "required": ["z"] }],
      "$comment": "Normalised fractions (0-1) representing transform-origin percentages, CALayer.anchorPoint, and View#setPivotX/Y."
    },
    "motion-rotation": {
      "type": "object",
      "required": ["angle"],
      "properties": {
        "angle": { "$ref": "#/$defs/motion-angle" },
        "axis": {
          "type": "object",
          "properties": {
            "x": { "type": "number" },
            "y": { "type": "number" },
            "z": { "type": "number" }
          },
          "additionalProperties": false,
          "minProperties": 1,
          "$comment": "Components describe the rotation vector consumed by rotate3d() (css-transforms-2#funcdef-rotate3d) and CATransform3DRotate."
        },
        "origin": { "$ref": "#/$defs/motion-origin" }
      },
      "additionalProperties": false
    },
    "motion-scale-factor": {
      "type": "number",
      "minimum": 0,
      "$comment": "Non-negative multiplier matching CSS scale() arguments and native scale factors; negative multipliers remain invalid."
    },
    "motion-scale": {
      "type": "object",
      "properties": {
        "x": { "$ref": "#/$defs/motion-scale-factor" },
        "y": { "$ref": "#/$defs/motion-scale-factor" },
        "z": { "$ref": "#/$defs/motion-scale-factor" },
        "uniform": { "$ref": "#/$defs/motion-scale-factor" }
      },
      "additionalProperties": false,
      "anyOf": [
        { "required": ["uniform"] },
        { "required": ["x"] },
        { "required": ["y"] },
        { "required": ["z"] }
      ]
    },
    "motion-path": {
      "type": "object",
      "required": ["points"],
      "properties": {
        "points": {
          "type": "array",
          "minItems": 2,
          "items": { "$ref": "#/$defs/motion-path-point" }
        }
      },
      "additionalProperties": false,
      "$comment": "Path definitions align with CSS offset-path path() geometry, CAKeyframeAnimation.path, and android.graphics.Path."
    },
    "motion-path-point": {
      "type": "object",
      "required": ["time", "position"],
      "properties": {
        "time": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "$comment": "Normalised progress matching CAKeyframeAnimation.keyTimes and ObjectAnimator fractions."
        },
        "position": { "$ref": "#/$defs/motion-path-position" },
        "easing": { "$ref": "#/$defs/pointer" }
      },
      "additionalProperties": false
    },
    "motion-path-position": {
      "type": "object",
      "properties": {
        "x": { "$ref": "#/$defs/motion-length" },
        "y": { "$ref": "#/$defs/motion-length" },
        "z": { "$ref": "#/$defs/motion-length" }
      },
      "additionalProperties": false,
      "anyOf": [{ "required": ["x"] }, { "required": ["y"] }, { "required": ["z"] }],
      "$comment": "Each axis resolves to <length-percentage> coordinates evaluated along the referenced path geometry."
    },
    "elevation": {
      "type": "object",
      "required": ["elevationType", "offset", "blur", "color"],
      "properties": {
        "elevationType": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*(?:\\.[a-z0-9-]+)*$",
          "$comment": "MUST identify the rendering context defined by CSS <shadow> functions, UIKit CALayer/NSShadow properties, or Android elevation/shadow APIs (for example css.box-shadow.surface, ios.layer.surface, android.paint.shadow-layer.surface)."
        },
        "offset": {
          "$ref": "#/$defs/lengthDimensionReference",
          "$comment": "Vertical offset MUST conform to CSS <length> grammar and map to CALayer.shadowOffset.height, Paint#setShadowLayer dy, or View#setElevation displacement."
        },
        "blur": {
          "$ref": "#/$defs/lengthDimensionReference",
          "$comment": "Blur radius MUST match the <length> position in CSS <shadow> and the CALayer.shadowRadius / Paint#setShadowLayer radius semantics."
        },
        "color": {
          "$ref": "#/$defs/colorReference",
          "$comment": "Shadow colour MUST conform to CSS <color> values and map to CGColor / Android colour integers used for Paint#setShadowLayer or elevation overlays."
        }
      },
      "additionalProperties": false
    },
    "lifecycle-metadata": {
      "title": "Lifecycle telemetry requirements",
      "description": "Ensures $lastUsed timestamps and $usageCount counters follow Metadata §table requirements.",
      "$comment": "Metadata table: $lastUsed requires $usageCount > 0; $usageCount = 0 forbids $lastUsed.",
      "allOf": [
        {
          "if": { "required": ["$lastModified", "$lastUsed"] },
          "then": {
            "$comment": "$lastUsed timestamps MUST NOT precede $lastModified (Metadata table).",
            "properties": {
              "$lastUsed": {
                "type": "string",
                "format": "date-time",
                "title": "$lastUsed not before $lastModified",
                "description": "$lastUsed MUST be on or after $lastModified when both fields are present.",
                "formatMinimum": { "$data": "1/$lastModified" }
              }
            }
          }
        },
        {
          "if": { "required": ["$lastUsed"] },
          "then": {
            "$comment": "$lastUsed requires a recorded usage count greater than zero.",
            "required": ["$usageCount"],
            "properties": {
              "$usageCount": {
                "minimum": 1,
                "description": "$usageCount MUST be a positive integer when $lastUsed is present.",
                "title": "$usageCount for used tokens"
              }
            }
          }
        },
        {
          "if": {
            "properties": { "$usageCount": { "const": 0 } },
            "required": ["$usageCount"]
          },
          "then": {
            "$comment": "$usageCount = 0 indicates no recorded usage, so $lastUsed MUST be omitted.",
            "not": { "required": ["$lastUsed"] }
          }
        },
        {
          "if": {
            "properties": { "$usageCount": { "minimum": 1 } },
            "required": ["$usageCount"]
          },
          "then": {
            "$comment": "Recorded usage counts greater than zero require a companion $lastUsed timestamp.",
            "required": ["$lastUsed"]
          }
        }
      ]
    },
    "trimmedString": {
      "title": "Trimmed string",
      "description": "Non-empty string without leading or trailing whitespace per Metadata §metadata.",
      "$comment": "Metadata table: strings such as $author MUST be trimmed.",
      "type": "string",
      "minLength": 1,
      "pattern": "^(?!\\s)(?:.*\\S)?$"
    },
    "hashString": {
      "title": "Hash string",
      "description": "Stable identifier with no whitespace per Metadata §metadata.",
      "$comment": "Metadata table: $hash MUST NOT contain whitespace.",
      "type": "string",
      "minLength": 1,
      "pattern": "^\\S+$"
    },
    "tags": {
      "title": "Tag list",
      "description": "Array of unique trimmed classification strings per Metadata §metadata.",
      "$comment": "Metadata table: $tags MUST contain unique trimmed strings.",
      "type": "array",
      "items": { "$ref": "#/$defs/trimmedString" },
      "uniqueItems": true
    },
    "function": {
      "title": "Function expression",
      "description": "Computed value wrapper with a function name and parameters per Token types §value.",
      "$comment": "Token types §value: $value MAY be a function object with fn and parameters members.",
      "type": "object",
      "required": ["fn", "parameters"],
      "properties": {
        "fn": {
          "title": "Function identifier",
          "description": "Function name such as calc, clamp, or platform-specific identifiers per Token types §value.",
          "type": "string"
        },
        "parameters": {
          "title": "Function parameters",
          "description": "Ordered list of literals, references, nested functions, or arrays per Token types §value.",
          "type": "array",
          "items": { "$ref": "#/$defs/function-parameter" }
        }
      },
      "additionalProperties": false
    },
    "function-parameter": {
      "title": "Function parameter",
      "description": "Literal, reference, nested function, array, or object argument accepted by function expressions per Token types §value.",
      "$comment": "Token types §value: parameters MAY include literals, $ref aliases, nested functions, or arrays.",
      "anyOf": [
        { "type": ["string", "number", "boolean", "null"] },
        { "$ref": "#/$defs/function" },
        {
          "type": "array",
          "items": { "$ref": "#/$defs/function-parameter" }
        },
        { "$ref": "#/$defs/reference" },
        {
          "type": "object",
          "not": { "required": ["$ref"] },
          "additionalProperties": true
        }
      ]
    },
    "extensions": {
      "title": "Extensions map",
      "description": "Namespaced metadata keyed by reverse-DNS identifiers per Format and serialisation §$extensions.",
      "$comment": "Format and serialisation §$extensions: keys MUST use lower-case reverse-DNS identifiers.",
      "type": "object",
      "propertyNames": {
        "pattern": "^[a-z0-9]+(?:\\.[a-z0-9]+)+$",
        "$comment": "Extension identifiers MUST be lower-case reverse-DNS strings."
      },
      "additionalProperties": true
    }
  }
}
