/* eslint-disable */
/**
 * This file was automatically generated by dtsgenerator.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSON Schema file,
 * and run the build to regenerate this file.
 */
/**
 * Architecture and model §tokens-and-collections: document members other than $-prefixed metadata are tokens or nested collections.
 * Design Token Interchange Format
 * Tree of design token or collection entries keyed by names that do not begin with $.
 */
export interface CoreJson {
    /**
     * Format and serialisation §format: documents MAY declare $schema for tooling introspection.
     * Schema declaration
     * Optional JSON Schema identifier that helps tooling discover compatible vocabularies.
     */
    $schema?: string;
    $description?: CoreJson.Definitions.MetadataMembers.Properties.$Description;
    /**
     * Architecture and model §versioning.
     * Document version
     * Semantic Versioning identifier for the token document per Architecture and model §versioning.
     */
    $version?: string; // ^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-(?:0|[1-9]\d*|[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|[a-zA-Z-][0-9a-zA-Z-]*))*)?(?:\+[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*)?$
    /**
     * Format and serialisation §$extensions.
     * Document extensions
     * Namespaced metadata that applies to the entire document per Format and serialisation §$extensions.
     */
    $extensions?: {
        [name: string]: any;
    };
    /**
     * Theming and overrides §$overrides.
     * Overrides
     * Conditional overrides evaluated in order per Theming and overrides §$overrides.
     */
    $overrides?: CoreJson.Definitions.Override[];
}
export namespace CoreJson {
    namespace Definitions {
        export interface AngleDimension {
            dimensionType: "angle";
            value: number;
            /**
             * MUST conform to CSS <angle> production (css-values-4).
             */
            unit: string; // ^[A-Za-z][A-Za-z0-9-]*$
        }
        /**
         * Token types §dimension: angle measurements MAY be serialized inline or referenced via $ref.
         * Angle dimension literal or alias
         * Angle measurement or $ref alias per Token types §dimension (angle) and Format and serialisation §$ref.
         */
        export type AngleDimensionReference = /**
         * Token types §dimension: angle measurements MAY be serialized inline or referenced via $ref.
         * Angle dimension literal or alias
         * Angle measurement or $ref alias per Token types §dimension (angle) and Format and serialisation §$ref.
         */ AngleDimension | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference;
        export interface Border {
            /**
             * MUST identify CSS border/outline contexts or native stroke APIs such as CALayer and GradientDrawable.
             * Border context identifier
             * Platform-qualified border context such as css.border, ios.layer.border, or android.shape.stroke.
             */
            borderType: string; // ^(?:css|ios|android)(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)+$
            /**
             * Width MUST follow the <line-width> grammar, accepting CSS keywords or dimension values that respect point/density conversions for pt, dp, and sp units.
             */
            width: /* Width MUST follow the <line-width> grammar, accepting CSS keywords or dimension values that respect point/density conversions for pt, dp, and sp units. */ /**
             * Token types §dimension: $value entries MAY embed literal measurements or $ref aliases that resolve to the same $type.
             * Dimension literal or alias
             * Inline dimension measurement or $ref alias per Token types §dimension and Format and serialisation §$ref.
             */ DimensionReference | ("thin" | "medium" | "thick");
            /**
             * Token types §border tokens: style MUST match CSS <line-style> keywords none, hidden, dotted, dashed, solid, double, groove, ridge, inset, or outset (css-backgrounds-3).
             * Border line style
             * CSS <line-style> keyword such as solid, dashed, or inset per Token types §border tokens.
             */
            style: "none" | "hidden" | "dotted" | "dashed" | "solid" | "double" | "groove" | "ridge" | "inset" | "outset";
            /**
             * Optional strokeStyle metadata MUST capture dash, cap, and join semantics compatible with CSS border-image, SVG stroke, CAShapeLayer.lineDashPattern, and Android Paint#setPathEffect.
             */
            strokeStyle?: /* Optional strokeStyle metadata MUST capture dash, cap, and join semantics compatible with CSS border-image, SVG stroke, CAShapeLayer.lineDashPattern, and Android Paint#setPathEffect. */ StrokeStyle | /**
             * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
             * Pointer alias
             * Object aliasing another token via $ref per Token types §value.
             */ Reference;
            /**
             * Border colour MUST conform to CSS <color> values and convert to CGColor or Android colour integers.
             */
            color: ColorReference;
            radius?: /**
             * Token types §dimension: $value entries MAY embed literal measurements or $ref aliases that resolve to the same $type.
             * Dimension literal or alias
             * Inline dimension measurement or $ref alias per Token types §dimension and Format and serialisation §$ref.
             */ DimensionReference | {
                topLeft?: BorderCornerRadius;
                topRight?: BorderCornerRadius;
                bottomRight?: BorderCornerRadius;
                bottomLeft?: BorderCornerRadius;
                topStart?: BorderCornerRadius;
                topEnd?: BorderCornerRadius;
                bottomStart?: BorderCornerRadius;
                bottomEnd?: BorderCornerRadius;
            };
        }
        export type BorderCornerRadius = /**
         * Token types §dimension: $value entries MAY embed literal measurements or $ref aliases that resolve to the same $type.
         * Dimension literal or alias
         * Inline dimension measurement or $ref alias per Token types §dimension and Format and serialisation §$ref.
         */ DimensionReference | {
            /**
             * Horizontal radius MUST conform to CSS <length-percentage> and native point/density semantics.
             */
            x: DimensionReference;
            /**
             * Optional vertical radius MUST conform to CSS <length-percentage>; when omitted, consumers reuse the horizontal value.
             */
            y?: DimensionReference;
        };
        /**
         * Token types §border tokens and §value: border tokens MAY embed direct values, $ref aliases, or functions.
         * Border value entry
         * Literal border payload, alias, or computed expression per Token types §border tokens.
         */
        export type BorderValueEntry = /**
         * Token types §border tokens and §value: border tokens MAY embed direct values, $ref aliases, or functions.
         * Border value entry
         * Literal border payload, alias, or computed expression per Token types §border tokens.
         */ Border | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Border fallback list
         * Ordered fallback list of border values evaluated per Token types §value.
         */
        export type BorderValueFallback = [
            /**
             * Token types §border tokens and §value: border tokens MAY embed direct values, $ref aliases, or functions.
             * Border value entry
             * Literal border payload, alias, or computed expression per Token types §border tokens.
             */
            BorderValueEntry,
            ...BorderValueEntry[]
        ];
        /**
         * Architecture and model §tokens-and-collections.
         * Token collection
         * Object without $value whose non-reserved members are tokens or collections per Architecture and model §tokens-and-collections.
         */
        export type Collection = TokenMemberMap & {
            /**
             * Metadata table: $description is optional free-form text.
             * Description
             * Human-readable explanation preserved for design intent per Metadata §metadata.
             */
            $description?: MetadataMembers.Properties.$Description;
            /**
             * Format and serialisation §$extensions: keys MUST use lower-case reverse-DNS identifiers.
             * Extensions map
             * Namespaced metadata keyed by reverse-DNS identifiers per Format and serialisation §$extensions.
             */
            $extensions?: MetadataMembers.Properties.$Extensions;
            /**
             * Metadata table: $deprecated MAY be a boolean or an object with $replacement.
             * Deprecation metadata
             * Boolean indicator or replacement pointer per Metadata §metadata.
             */
            $deprecated?: MetadataMembers.Properties.$Deprecated;
            /**
             * Metadata table: $lastModified establishes the lower bound for $lastUsed.
             * Last modified timestamp
             * RFC 3339 date-time recording governance actions per Metadata §metadata.
             */
            $lastModified?: MetadataMembers.Properties.$LastModified /* date-time */; // date-time
            /**
             * Metadata table: $lastUsed MUST NOT precede $lastModified and requires $usageCount > 0.
             * Last used timestamp
             * RFC 3339 date-time capturing usage telemetry per Metadata §metadata.
             */
            $lastUsed?: MetadataMembers.Properties.$LastUsed /* date-time */; // date-time
            /**
             * Metadata table: $usageCount records adoption and pairs with $lastUsed when greater than zero.
             * Usage count
             * Non-negative adoption counter per Metadata §metadata.
             */
            $usageCount?: MetadataMembers.Properties.$UsageCount;
            /**
             * Metadata table: strings such as $author MUST be trimmed.
             * Trimmed string
             * Non-empty string without leading or trailing whitespace per Metadata §metadata.
             */
            $author?: MetadataMembers.Properties.$Author /* ^(?!\s)(?:.*\S)?$ */; // ^(?!\s)(?:.*\S)?$
            /**
             * Metadata table: $tags MUST contain unique trimmed strings.
             * Tag list
             * Array of unique trimmed classification strings per Metadata §metadata.
             */
            $tags?: MetadataMembers.Properties.$Tags;
            /**
             * Metadata table: $hash MUST NOT contain whitespace.
             * Hash string
             * Stable identifier with no whitespace per Metadata §metadata.
             */
            $hash?: MetadataMembers.Properties.$Hash /* ^\S+$ */; // ^\S+$
        };
        export interface Color {
            colorSpace: CssIdent /* ^-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*$ */;
            /**
             * Channel order, ranges, and optional alpha MUST follow CSS Color 4 for the referenced colour space (css-color-4).
             */
            components: [
                number,
                ...number[]
            ];
            /**
             * Optional CSS hexadecimal colour serialization (css-color-4).
             */
            hex?: string; // ^#(?:[0-9A-Fa-f]{3}|[0-9A-Fa-f]{4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$
            /**
             * Optional fallback alpha matching CSS <alpha-value> semantics (css-color-4).
             */
            alpha?: number;
        }
        /**
         * Token types §gradient tokens and css-images-4: hint strings MUST be a solitary <length-percentage> expression without an optional second stop.
         * Color hint length string
         * CSS <color-hint> token serialized as a single <length-percentage> entry per Token types §gradient tokens.
         * example:
         * 25%
         * calc(10% + 2rem)
         * var(--hint)
         */
        export type ColorHintLengthString = string; // ^(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+))$
        /**
         * Token types §color: $value entries MAY embed literal colour objects or $ref aliases that resolve to the same $type.
         * Color literal or alias
         * Inline colour payload or $ref alias per Token types §color and Format and serialisation §$ref.
         */
        export type ColorReference = /**
         * Token types §color: $value entries MAY embed literal colour objects or $ref aliases that resolve to the same $type.
         * Color literal or alias
         * Inline colour payload or $ref alias per Token types §color and Format and serialisation §$ref.
         */ Color | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference;
        /**
         * Token types §gradient tokens and css-images-4: stop positions expressed as strings MUST be a single <length-percentage> or a pair separated by ASCII whitespace.
         * Color stop length string
         * CSS <color-stop-length> token composed of one or two <length-percentage> entries per Token types §gradient tokens.
         * example:
         * 0%
         * calc(50% - 10px)
         * var(--stop, 25%)
         */
        export type ColorStopLengthString = string; // ^(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+))(?:\s+(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+)))?$
        /**
         * Token types §color and §value: color tokens MAY embed direct values, $ref aliases, or functions.
         * Color value entry
         * Literal colour payload, alias, or computed expression per Token types §color.
         */
        export type ColorValueEntry = /**
         * Token types §color and §value: color tokens MAY embed direct values, $ref aliases, or functions.
         * Color value entry
         * Literal colour payload, alias, or computed expression per Token types §color.
         */ Color | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Color fallback list
         * Ordered fallback list of colour values evaluated per Token types §value.
         */
        export type ColorValueFallback = [
            /**
             * Token types §color and §value: color tokens MAY embed direct values, $ref aliases, or functions.
             * Color value entry
             * Literal colour payload, alias, or computed expression per Token types §color.
             */
            ColorValueEntry,
            ...ColorValueEntry[]
        ];
        /**
         * Token types §shadow tokens, §gradient tokens, and §elevation tokens use dotted identifiers that mirror CSS and native surface nomenclature.
         * Rendering context identifier
         * Lower-case identifier describing rendering surfaces such as css.box-shadow or ios.layer.
         */
        export type ContextIdentifier = string; // ^[a-z][a-z0-9-]*(?:\.[a-z0-9-]+)*$
        /**
         * Typography §font and §font-face: fontFamily, family, and fallback strings MUST follow the CSS <family-name> production allowing quoted names or sequences of <ident> tokens.
         * CSS family name
         * Font family string following the CSS <family-name> grammar per CSS Fonts Module Level 4 §font-family-names.
         */
        export type CssFamilyName = /**
         * Typography §font and §font-face: fontFamily, family, and fallback strings MUST follow the CSS <family-name> production allowing quoted names or sequences of <ident> tokens.
         * CSS family name
         * Font family string following the CSS <family-name> grammar per CSS Fonts Module Level 4 §font-family-names.
         */ string /* ^(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+')$ */ | string /* ^-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*(?:[ \t]+-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*)*$ */;
        /**
         * MUST conform to CSS <ident> / <dashed-ident> productions including Unicode escapes (css-values-4, css-syntax-3).
         * CSS identifier
         * Identifier matching the CSS <ident> or <dashed-ident> grammar per CSS Values and Units §css-identifier-syntax.
         */
        export type CssIdent = string; // ^-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*$
        export interface Cursor {
            /**
             * MUST identify pointer contexts defined by CSS cursor grammars, UIKit UIPointerStyle APIs, or Android PointerIcon classes (e.g. css.cursor, ios.uipointerstyle, android.pointer-icon).
             * Cursor context identifier
             * Platform-qualified cursor context such as css.cursor, ios.uipointerstyle, or android.pointer-icon.
             */
            cursorType: string; // ^(?:css|ios|android)(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)+$
            value: string | {
                [name: string]: any;
            };
            /**
             * Optional parameters supply reusable inputs such as hotspot coordinates or referenced tokens consumed by pointer APIs.
             */
            parameters?: {
                [name: string]: any;
            };
        }
        /**
         * Token types §cursor and §value: cursor tokens MAY embed direct values, $ref aliases, or functions.
         * Cursor value entry
         * Literal cursor payload, alias, or computed expression per Token types §cursor.
         */
        export type CursorValueEntry = /**
         * Token types §cursor and §value: cursor tokens MAY embed direct values, $ref aliases, or functions.
         * Cursor value entry
         * Literal cursor payload, alias, or computed expression per Token types §cursor.
         */ Cursor | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Cursor fallback list
         * Ordered fallback list of cursor values evaluated per Token types §value.
         */
        export type CursorValueFallback = [
            /**
             * Token types §cursor and §value: cursor tokens MAY embed direct values, $ref aliases, or functions.
             * Cursor value entry
             * Literal cursor payload, alias, or computed expression per Token types §cursor.
             */
            CursorValueEntry,
            ...CursorValueEntry[]
        ];
        export interface Dimension {
            dimensionType: "length" | "angle" | "resolution" | "custom";
            value: number;
            unit: string;
            /**
             * When true, MUST follow Dynamic Type (IOS-DYNAMIC-TYPE) and Android scale-independent behaviour (ANDROID-DP-SP).
             * Whether the value scales with the user's font settings.
             */
            fontScale?: boolean;
        }
        /**
         * Token types §dimension: $value entries MAY embed literal measurements or $ref aliases that resolve to the same $type.
         * Dimension literal or alias
         * Inline dimension measurement or $ref alias per Token types §dimension and Format and serialisation §$ref.
         */
        export type DimensionReference = /**
         * Token types §dimension: $value entries MAY embed literal measurements or $ref aliases that resolve to the same $type.
         * Dimension literal or alias
         * Inline dimension measurement or $ref alias per Token types §dimension and Format and serialisation §$ref.
         */ Dimension | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference;
        /**
         * Token types §dimension and §value: dimension tokens MAY embed direct values, $ref aliases, or functions.
         * Dimension value entry
         * Literal measurement, alias, or computed expression per Token types §dimension.
         */
        export type DimensionValueEntry = 
        /**
         * Token types §dimension: $value entries MAY embed literal measurements or $ref aliases that resolve to the same $type.
         * Dimension literal or alias
         * Inline dimension measurement or $ref alias per Token types §dimension and Format and serialisation §$ref.
         */
        /**
         * Token types §dimension and §value: dimension tokens MAY embed direct values, $ref aliases, or functions.
         * Dimension value entry
         * Literal measurement, alias, or computed expression per Token types §dimension.
         */ DimensionReference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Dimension fallback list
         * Ordered fallback list of dimension values evaluated per Token types §value.
         */
        export type DimensionValueFallback = [
            /**
             * Token types §dimension and §value: dimension tokens MAY embed direct values, $ref aliases, or functions.
             * Dimension value entry
             * Literal measurement, alias, or computed expression per Token types §dimension.
             */
            DimensionValueEntry,
            ...DimensionValueEntry[]
        ];
        export interface Duration {
            /**
             * MUST identify a duration context defined by CSS Transitions/Animations, Core Animation, UIViewPropertyAnimator, or Android animator APIs (for example css.transition-duration, ios.caanimation.duration, android.value-animator.duration, ios.cadisplaylink.frame-count).
             * Duration context identifier
             * Platform-qualified duration context such as css.transition-duration, ios.caanimation.duration, or android.value-animator.duration.
             */
            durationType: string; // ^(?:css|ios|android)(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)+$
            value: number;
            /**
             * MUST serialise the unit token defined by the referenced duration grammar (css-values-4#time-value, css-values-4#percentages, IOS-CADISPLAYLINK, ANDROID-CHOREOGRAPHER).
             */
            unit: string;
        }
        /**
         * Token types §duration and §value: duration tokens MAY embed direct values, $ref aliases, or functions.
         * Duration value entry
         * Duration payload, alias, or computed expression per Token types §duration.
         */
        export type DurationValueEntry = /**
         * Token types §duration and §value: duration tokens MAY embed direct values, $ref aliases, or functions.
         * Duration value entry
         * Duration payload, alias, or computed expression per Token types §duration.
         */ Duration | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Duration fallback list
         * Ordered fallback list of duration values evaluated per Token types §value.
         */
        export type DurationValueFallback = [
            /**
             * Token types §duration and §value: duration tokens MAY embed direct values, $ref aliases, or functions.
             * Duration value entry
             * Duration payload, alias, or computed expression per Token types §duration.
             */
            DurationValueEntry,
            ...DurationValueEntry[]
        ];
        /**
         * Token types §easing: easingFunction names a CSS <single-easing-function> or native analogue and parameters follow that grammar.
         * Easing payload
         * Reusable timing curve identified by easingFunction per Token types §easing.
         */
        export interface Easing {
            /**
             * MUST name a CSS <single-easing-function> production or a documented native analogue.
             * Easing function identifier
             * CSS or vendor-qualified easing identifier such as cubic-bezier, steps, ios.spring, or android.spring-force.
             */
            easingFunction: string; // ^[a-z][a-z0-9-]*(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)*$
            /**
             * When present, MUST satisfy the argument grammar defined for the referenced easing function in CSS Easing Functions or platform timing APIs.
             * Easing parameters
             * Ordered arguments consumed by the referenced easingFunction. Omit when the grammar takes no parameters.
             */
            parameters?: (number | string)[];
        }
        /**
         * Token types §easing and §value: easing tokens MAY embed direct values, $ref aliases, or functions.
         * Easing value entry
         * Literal easing payload, alias, or computed expression per Token types §easing.
         */
        export type EasingValueEntry = 
        /**
         * Token types §easing: easingFunction names a CSS <single-easing-function> or native analogue and parameters follow that grammar.
         * Easing payload
         * Reusable timing curve identified by easingFunction per Token types §easing.
         */
        /**
         * Token types §easing and §value: easing tokens MAY embed direct values, $ref aliases, or functions.
         * Easing value entry
         * Literal easing payload, alias, or computed expression per Token types §easing.
         */ Easing | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Easing fallback list
         * Ordered fallback list of easing values evaluated per Token types §value.
         */
        export type EasingValueFallback = [
            /**
             * Token types §easing and §value: easing tokens MAY embed direct values, $ref aliases, or functions.
             * Easing value entry
             * Literal easing payload, alias, or computed expression per Token types §easing.
             */
            EasingValueEntry,
            ...EasingValueEntry[]
        ];
        export interface Elevation {
            /**
             * MUST identify the rendering context defined by CSS <shadow> functions, UIKit CALayer/NSShadow properties, or Android elevation/shadow APIs (for example css.box-shadow.surface, ios.layer.surface, android.paint.shadow-layer.surface).
             * Elevation context identifier
             * Rendering surface identifier such as css.box-shadow.surface, ios.layer.surface, or android.paint.shadow-layer.surface.
             */
            elevationType: string; // ^[a-z][a-z0-9-]*(?:\.[a-z0-9-]+)*$
            /**
             * Vertical offset MUST conform to CSS <length> grammar and map to CALayer.shadowOffset.height, Paint#setShadowLayer dy, or View#setElevation displacement.
             */
            offset: LengthDimensionReference;
            /**
             * Blur radius MUST match the <length> position in CSS <shadow> and the CALayer.shadowRadius / Paint#setShadowLayer radius semantics.
             * Elevation blur radius
             * Length measurement describing the ambient blur per Token types §elevation tokens.
             */
            blur: /**
             * Blur radius MUST match the <length> position in CSS <shadow> and the CALayer.shadowRadius / Paint#setShadowLayer radius semantics.
             * Elevation blur radius
             * Length measurement describing the ambient blur per Token types §elevation tokens.
             */ LengthDimension | /**
             * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
             * Pointer alias
             * Object aliasing another token via $ref per Token types §value.
             */ Reference;
            /**
             * Shadow colour MUST conform to CSS <color> values and map to CGColor / Android colour integers used for Paint#setShadowLayer or elevation overlays.
             */
            color: ColorReference;
        }
        /**
         * Token types §elevation tokens and §value: elevation tokens MAY embed direct values, $ref aliases, or functions.
         * Elevation value entry
         * Literal elevation payload, alias, or computed expression per Token types §elevation tokens.
         */
        export type ElevationValueEntry = /**
         * Token types §elevation tokens and §value: elevation tokens MAY embed direct values, $ref aliases, or functions.
         * Elevation value entry
         * Literal elevation payload, alias, or computed expression per Token types §elevation tokens.
         */ Elevation | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Elevation fallback list
         * Ordered fallback list of elevation values evaluated per Token types §value.
         */
        export type ElevationValueFallback = [
            /**
             * Token types §elevation tokens and §value: elevation tokens MAY embed direct values, $ref aliases, or functions.
             * Elevation value entry
             * Literal elevation payload, alias, or computed expression per Token types §elevation tokens.
             */
            ElevationValueEntry,
            ...ElevationValueEntry[]
        ];
        /**
         * Format and serialisation §$extensions: keys MUST use lower-case reverse-DNS identifiers.
         * Extensions map
         * Namespaced metadata keyed by reverse-DNS identifiers per Format and serialisation §$extensions.
         */
        export interface Extensions {
            [name: string]: any;
        }
        /**
         * Theming and overrides §$overrides: $fallback MAY be a single entry or an array processed sequentially.
         * Fallback chain
         * Single fallback entry or ordered array evaluated when primary overrides fail per Theming and overrides §$overrides.
         */
        export type Fallback = 
        /**
         * Theming and overrides §$overrides: fallback entries mirror override semantics.
         * Fallback entry
         * Single fallback candidate containing a $ref or inline $value per Theming and overrides §$overrides.
         */
        /**
         * Theming and overrides §$overrides: $fallback MAY be a single entry or an array processed sequentially.
         * Fallback chain
         * Single fallback entry or ordered array evaluated when primary overrides fail per Theming and overrides §$overrides.
         */ FallbackEntry | [
            /**
             * Theming and overrides §$overrides: fallback entries mirror override semantics.
             * Fallback entry
             * Single fallback candidate containing a $ref or inline $value per Theming and overrides §$overrides.
             */
            FallbackEntry,
            ...FallbackEntry[]
        ];
        /**
         * Theming and overrides §$overrides: fallback entries mirror override semantics.
         * Fallback entry
         * Single fallback candidate containing a $ref or inline $value per Theming and overrides §$overrides.
         */
        export type FallbackEntry = /**
         * Theming and overrides §$overrides: fallback entries mirror override semantics.
         * Fallback entry
         * Single fallback candidate containing a $ref or inline $value per Theming and overrides §$overrides.
         */ {
            /**
             * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
             * Fallback reference
             * Pointer to an alternate token per Theming and overrides §$overrides.
             */
            $ref: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
        } | {
            $value: any;
            /**
             * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
             * Fallback reference
             * Pointer to an alternate token per Theming and overrides §$overrides.
             */
            $ref?: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
        };
        /**
         * Theming and overrides §$overrides.
         * Fallback entry members
         * Shared fallback members evaluated when overrides fail per Theming and overrides §$overrides.
         */
        export interface FallbackEntryCore {
            /**
             * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
             * Fallback reference
             * Pointer to an alternate token per Theming and overrides §$overrides.
             */
            $ref?: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
            /**
             * Fallback values must conform to the overridden token's $type.
             * Inline fallback value
             * Inline fallback that MUST conform to the overridden token's $type per Theming and overrides §$overrides.
             */
            $value?: any;
            /**
             * Theming and overrides §$overrides: $fallback MAY be a single entry or an array processed sequentially.
             * Nested fallback
             * Optional nested fallback chain evaluated when this entry fails per Theming and overrides §$overrides.
             */
            $fallback?: 
            /**
             * Theming and overrides §$overrides: fallback entries mirror override semantics.
             * Fallback entry
             * Single fallback candidate containing a $ref or inline $value per Theming and overrides §$overrides.
             */
            /**
             * Theming and overrides §$overrides: $fallback MAY be a single entry or an array processed sequentially.
             * Nested fallback
             * Optional nested fallback chain evaluated when this entry fails per Theming and overrides §$overrides.
             */ FallbackEntry | [
                /**
                 * Theming and overrides §$overrides: fallback entries mirror override semantics.
                 * Fallback entry
                 * Single fallback candidate containing a $ref or inline $value per Theming and overrides §$overrides.
                 */
                FallbackEntry,
                ...FallbackEntry[]
            ];
        }
        export interface Filter {
            /**
             * MUST identify the rendering context defined by CSS filter(), Core Image CIFilter pipelines, or Android RenderEffect chains (for example css.filter, ios.cifilter, android.render-effect).
             * Filter context identifier
             * Platform-qualified filter context such as css.filter, ios.cifilter, or android.render-effect.
             */
            filterType: string; // ^(?:css|ios|android)(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)+$
            /**
             * Represents the ordered <filter-function-list> grammar from CSS Filter Effects.
             */
            operations: [
                {
                    /**
                     * MUST reference a filter function from CSS Filter Effects Module Level 1 or its native analogue (for example blur, brightness, drop-shadow).
                     * Filter function identifier
                     * Function name from CSS Filter Effects or a vendor-qualified analogue such as blur, brightness, or ios.cifilter.gaussian-blur.
                     */
                    fn: string; // ^[a-z][a-z0-9-]*(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)*$
                    /**
                     * Arguments MUST satisfy the grammar of the referenced filter function (e.g. CSS blur() <length>, brightness() numbers, drop-shadow() <shadow>) and map to CIFilter / RenderEffect parameters.
                     */
                    parameters?: FunctionParameter[];
                },
                ...{
                    /**
                     * MUST reference a filter function from CSS Filter Effects Module Level 1 or its native analogue (for example blur, brightness, drop-shadow).
                     * Filter function identifier
                     * Function name from CSS Filter Effects or a vendor-qualified analogue such as blur, brightness, or ios.cifilter.gaussian-blur.
                     */
                    fn: string; // ^[a-z][a-z0-9-]*(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)*$
                    /**
                     * Arguments MUST satisfy the grammar of the referenced filter function (e.g. CSS blur() <length>, brightness() numbers, drop-shadow() <shadow>) and map to CIFilter / RenderEffect parameters.
                     */
                    parameters?: FunctionParameter[];
                }[]
            ];
        }
        /**
         * Token types §filter tokens and §value: filter tokens MAY embed direct values, $ref aliases, or functions.
         * Filter value entry
         * Literal filter payload, alias, or computed expression per Token types §filter tokens.
         */
        export type FilterValueEntry = /**
         * Token types §filter tokens and §value: filter tokens MAY embed direct values, $ref aliases, or functions.
         * Filter value entry
         * Literal filter payload, alias, or computed expression per Token types §filter tokens.
         */ Filter | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Filter fallback list
         * Ordered fallback list of filter values evaluated per Token types §value.
         */
        export type FilterValueFallback = [
            /**
             * Token types §filter tokens and §value: filter tokens MAY embed direct values, $ref aliases, or functions.
             * Filter value entry
             * Literal filter payload, alias, or computed expression per Token types §filter tokens.
             */
            FilterValueEntry,
            ...FilterValueEntry[]
        ];
        export interface Font {
            /**
             * MUST identify platform context and asset source using dot-separated identifiers aligned with CSS Fonts src descriptors, UIKit UIFont APIs, or Android font resource/typeface loaders.
             * Font resource identifier
             * Platform-qualified font provider such as css.font-face, ios.uiFont, or android.font-resource.
             */
            fontType: string; // ^(?:css|ios|android)(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)+$
            /**
             * CSS Fonts §font-family-names and Typography §font require CSS <family-name> strings or platform catalog identifiers.
             * Font family
             * Family name following CSS <family-name> grammar or platform catalog registrations.
             */
            family: /**
             * CSS Fonts §font-family-names and Typography §font require CSS <family-name> strings or platform catalog identifiers.
             * Font family
             * Family name following CSS <family-name> grammar or platform catalog registrations.
             */ string /* ^(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+')$ */ | string /* ^-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*(?:[ \t]+-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*)*$ */;
            /**
             * Fallback stacks MUST preserve order and reuse CSS <family-name> grammar and generic family keywords (css-fonts-4) so they align with platform catalog registrations (IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
             */
            fallbacks?: [
                /**
                 * Typography §font and §font-face: fontFamily, family, and fallback strings MUST follow the CSS <family-name> production allowing quoted names or sequences of <ident> tokens.
                 * CSS family name
                 * Font family string following the CSS <family-name> grammar per CSS Fonts Module Level 4 §font-family-names.
                 */
                CssFamilyName,
                ...CssFamilyName[]
            ];
            /**
             * MUST conform to CSS <font-style-absolute> grammar (css-fonts-4); angles MUST follow <angle> (css-values-4).
             */
            style?: FontStyleString /* ^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Ii][Tt][Aa][Ll][Ii][Cc]|[Oo][Bb][Ll][Ii][Qq][Uu][Ee](?:\s+[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:[Dd][Ee][Gg]|[Gg][Rr][Aa][Dd]|[Rr][Aa][Dd]|[Tt][Uu][Rr][Nn]))?)$ */;
            weight?: number | /* String weights MUST conform to CSS <font-weight-absolute>, <font-weight-relative>, or <font-weight-range> productions (css-fonts-4). */ FontWeightString /* ^(?:[Bb][Oo][Ll][Dd][Ee][Rr]|[Ll][Ii][Gg][Hh][Tt][Ee][Rr]|(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?))(?:\s+(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?)))?)$ */;
        }
        export type FontDimension = {
            dimensionType: "length";
            value: number;
            /**
             * MUST conform to CSS <length> or <percentage> (css-values-4) or native point/density-independent units (IOS-POINTS, ANDROID-DP-SP).
             */
            unit: string; // ^(?:%|[A-Za-z][A-Za-z0-9-]*)$
            /**
             * When true, MUST follow Dynamic Type (IOS-DYNAMIC-TYPE) and Android scale-independent behaviour (ANDROID-DP-SP).
             * Whether the value scales with the user's font settings.
             */
            fontScale?: boolean;
        } | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference;
        /**
         * Typography §font-dimensions and §font-face: values MAY embed inline font measurements or alias another token with the same $type.
         * Font dimension literal or alias
         * Font-specific length measurement or $ref alias per Typography §font-dimensions and Format and serialisation §$ref.
         */
        export type FontDimensionReference = /**
         * Typography §font-dimensions and §font-face: values MAY embed inline font measurements or alias another token with the same $type.
         * Font dimension literal or alias
         * Font-specific length measurement or $ref alias per Typography §font-dimensions and Format and serialisation §$ref.
         */ {
            dimensionType: "length";
            value: number;
            /**
             * MUST conform to CSS <length> or <percentage> (css-values-4) or native point/density-independent units (IOS-POINTS, ANDROID-DP-SP).
             */
            unit: string; // ^(?:%|[A-Za-z][A-Za-z0-9-]*)$
            /**
             * When true, MUST follow Dynamic Type (IOS-DYNAMIC-TYPE) and Android scale-independent behaviour (ANDROID-DP-SP).
             * Whether the value scales with the user's font settings.
             */
            fontScale?: boolean;
        } | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference;
        export interface FontFace {
            /**
             * Entries MUST correspond to CSS @font-face src descriptors (css-fonts-4) and map to bundled/downloadable font resources registered through iOS font catalogs and Android font resources (IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
             */
            src: [
                ({
                    /**
                     * Font URLs MUST resolve to resources used by CSS url() and native registration APIs (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
                     * Font resource URL
                     * Relative or absolute URL compatible with CSS url() and native font registration APIs.
                     */
                    url: string; // uri-reference ^(?!\s)(?:.*\S)?$
                    /**
                     * Font format hints MUST match CSS src format() descriptors (css-fonts-4).
                     */
                    format?: /* Font format hints MUST match CSS src format() descriptors (css-fonts-4). */ string | [
                        string,
                        ...string[]
                    ];
                    /**
                     * Technology hints MUST align with CSS src tech() identifiers (css-fonts-4#font-tech-values).
                     */
                    tech?: [
                        string,
                        ...string[]
                    ];
                } | {
                    /**
                     * Local font references MUST match CSS src local() <family-name> grammar and platform catalog registrations (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
                     * Local font name
                     * Local font reference matching CSS src local() <family-name> grammar and platform catalogs.
                     */
                    local: /**
                     * Local font references MUST match CSS src local() <family-name> grammar and platform catalog registrations (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
                     * Local font name
                     * Local font reference matching CSS src local() <family-name> grammar and platform catalogs.
                     */ string /* ^(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+')$ */ | string /* ^-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*(?:[ \t]+-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*)*$ */;
                }),
                ...({
                    /**
                     * Font URLs MUST resolve to resources used by CSS url() and native registration APIs (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
                     * Font resource URL
                     * Relative or absolute URL compatible with CSS url() and native font registration APIs.
                     */
                    url: string; // uri-reference ^(?!\s)(?:.*\S)?$
                    /**
                     * Font format hints MUST match CSS src format() descriptors (css-fonts-4).
                     */
                    format?: /* Font format hints MUST match CSS src format() descriptors (css-fonts-4). */ string | [
                        string,
                        ...string[]
                    ];
                    /**
                     * Technology hints MUST align with CSS src tech() identifiers (css-fonts-4#font-tech-values).
                     */
                    tech?: [
                        string,
                        ...string[]
                    ];
                } | {
                    /**
                     * Local font references MUST match CSS src local() <family-name> grammar and platform catalog registrations (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
                     * Local font name
                     * Local font reference matching CSS src local() <family-name> grammar and platform catalogs.
                     */
                    local: /**
                     * Local font references MUST match CSS src local() <family-name> grammar and platform catalog registrations (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
                     * Local font name
                     * Local font reference matching CSS src local() <family-name> grammar and platform catalogs.
                     */ string /* ^(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+')$ */ | string /* ^-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*(?:[ \t]+-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*)*$ */;
                })[]
            ];
            /**
             * Typography §font-face requires CSS <family-name> strings or platform catalog identifiers (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
             * Font family
             * Family name following CSS <family-name> grammar or platform catalog registrations.
             */
            fontFamily: /**
             * Typography §font-face requires CSS <family-name> strings or platform catalog identifiers (css-fonts-4, IOS-FONT-CATALOG, ANDROID-FONT-FAMILY).
             * Font family
             * Family name following CSS <family-name> grammar or platform catalog registrations.
             */ string /* ^(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+')$ */ | string /* ^-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*(?:[ \t]+-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*)*$ */;
            fontWeight?: number | /* String weights MUST conform to CSS <font-weight-absolute>, <font-weight-relative>, or <font-weight-range> productions (css-fonts-4). */ FontWeightString /* ^(?:[Bb][Oo][Ll][Dd][Ee][Rr]|[Ll][Ii][Gg][Hh][Tt][Ee][Rr]|(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?))(?:\s+(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?)))?)$ */;
            /**
             * MUST conform to CSS font-style descriptor grammar (css-fonts-4); oblique angles map to the slnt variation axis per UIFontDescriptor.AttributeName.variations and Typeface.Builder#setFontVariationSettings (IOS-FONT-VARIATIONS, ANDROID-FONT-VARIATION).
             */
            fontStyle?: FontStyleString /* ^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Ii][Tt][Aa][Ll][Ii][Cc]|[Oo][Bb][Ll][Ii][Qq][Uu][Ee](?:\s+[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:[Dd][Ee][Gg]|[Gg][Rr][Aa][Dd]|[Rr][Aa][Dd]|[Tt][Uu][Rr][Nn]))?)$ */;
            /**
             * Stretch keywords MUST follow CSS <font-stretch-absolute> grammar (css-fonts-4).
             */
            fontStretch?: FontStretchString /* ^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|(?:[Uu][Ll][Tt][Rr][Aa]|[Ee][Xx][Tt][Rr][Aa]|[Ss][Ee][Mm][Ii])-[Cc][Oo][Nn][Dd][Ee][Nn][Ss][Ee][Dd]|[Cc][Oo][Nn][Dd][Ee][Nn][Ss][Ee][Dd]|(?:[Ss][Ee][Mm][Ii]|[Ee][Xx][Tt][Rr][Aa]|[Uu][Ll][Tt][Rr][Aa])-[Ee][Xx][Pp][Aa][Nn][Dd][Ee][Dd]|[Ee][Xx][Pp][Aa][Nn][Dd][Ee][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?)%)$ */;
            /**
             * Ranges MUST conform to the CSS unicode-range descriptor grammar (css-fonts-4).
             */
            unicodeRange?: string; // ^(?:U\+[0-9A-F?]{1,6}(?:-[0-9A-F?]{1,6})?)(?:\s*,\s*U\+[0-9A-F?]{1,6}(?:-[0-9A-F?]{1,6})?)*$
            /**
             * Display strategy MUST use the css-fonts-4 font-display keywords; native runtimes map these hints to preload/async policies.
             */
            fontDisplay?: string; // ^(?:[Aa][Uu][Tt][Oo]|[Bb][Ll][Oo][Cc][Kk]|[Ss][Ww][Aa][Pp]|[Ff][Aa][Ll][Ll][Bb][Aa][Cc][Kk]|[Oo][Pp][Tt][Ii][Oo][Nn][Aa][Ll])$
        }
        /**
         * Typography §font-face and Token types §value: fontFace tokens MAY embed direct values, $ref aliases, or functions.
         * Font face value entry
         * Literal font-face payload, alias, or computed expression per Typography §font-face.
         */
        export type FontFaceValueEntry = /**
         * Typography §font-face and Token types §value: fontFace tokens MAY embed direct values, $ref aliases, or functions.
         * Font face value entry
         * Literal font-face payload, alias, or computed expression per Typography §font-face.
         */ FontFace | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Font face fallback list
         * Ordered fallback list of font-face values evaluated per Token types §value.
         */
        export type FontFaceValueFallback = [
            /**
             * Typography §font-face and Token types §value: fontFace tokens MAY embed direct values, $ref aliases, or functions.
             * Font face value entry
             * Literal font-face payload, alias, or computed expression per Typography §font-face.
             */
            FontFaceValueEntry,
            ...FontFaceValueEntry[]
        ];
        /**
         * Font stretch values MUST match CSS <font-stretch-absolute> grammar (css-fonts-4).
         */
        export type FontStretchString = string; // ^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|(?:[Uu][Ll][Tt][Rr][Aa]|[Ee][Xx][Tt][Rr][Aa]|[Ss][Ee][Mm][Ii])-[Cc][Oo][Nn][Dd][Ee][Nn][Ss][Ee][Dd]|[Cc][Oo][Nn][Dd][Ee][Nn][Ss][Ee][Dd]|(?:[Ss][Ee][Mm][Ii]|[Ee][Xx][Tt][Rr][Aa]|[Uu][Ll][Tt][Rr][Aa])-[Ee][Xx][Pp][Aa][Nn][Dd][Ee][Dd]|[Ee][Xx][Pp][Aa][Nn][Dd][Ee][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?)%)$
        /**
         * Font style keywords MUST match CSS font-style grammar, optionally supplying an oblique angle (css-fonts-4, css-values-4).
         */
        export type FontStyleString = string; // ^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Ii][Tt][Aa][Ll][Ii][Cc]|[Oo][Bb][Ll][Ii][Qq][Uu][Ee](?:\s+[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:[Dd][Ee][Gg]|[Gg][Rr][Aa][Dd]|[Rr][Aa][Dd]|[Tt][Uu][Rr][Nn]))?)$
        /**
         * Token types §font and §value: font tokens MAY embed direct values, $ref aliases, or functions.
         * Font value entry
         * Literal font payload, alias, or computed expression per Token types §font.
         */
        export type FontValueEntry = /**
         * Token types §font and §value: font tokens MAY embed direct values, $ref aliases, or functions.
         * Font value entry
         * Literal font payload, alias, or computed expression per Token types §font.
         */ Font | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Font fallback list
         * Ordered fallback list of font values evaluated per Token types §value.
         */
        export type FontValueFallback = [
            /**
             * Token types §font and §value: font tokens MAY embed direct values, $ref aliases, or functions.
             * Font value entry
             * Literal font payload, alias, or computed expression per Token types §font.
             */
            FontValueEntry,
            ...FontValueEntry[]
        ];
        /**
         * Font variant sequences MUST match CSS font-variant grammar (css-fonts-4).
         */
        export type FontVariantString = string; // ^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Nn][Oo][Nn][Ee]|(?:(?:[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Nn][Oo]-[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Uu][Nn][Ii][Cc][Aa][Ss][Ee]|[Tt][Ii][Tt][Ll][Ii][Nn][Gg]-[Cc][Aa][Pp][Ss]|[Ll][Ii][Nn][Ii][Nn][Gg]-[Nn][Uu][Mm][Ss]|[Oo][Ll][Dd][Ss][Tt][Yy][Ll][Ee]-[Nn][Uu][Mm][Ss]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Nn][Uu][Mm][Ss]|[Tt][Aa][Bb][Uu][Ll][Aa][Rr]-[Nn][Uu][Mm][Ss]|[Dd][Ii][Aa][Gg][Oo][Nn][Aa][Ll]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Ss][Tt][Aa][Cc][Kk][Ee][Dd]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Oo][Rr][Dd][Ii][Nn][Aa][Ll]|[Ss][Ll][Aa][Ss][Hh][Ee][Dd]-[Zz][Ee][Rr][Oo]|[Jj][Ii][Ss]78|[Jj][Ii][Ss]83|[Jj][Ii][Ss]90|[Jj][Ii][Ss]04|[Ss][Ii][Mm][Pp][Ll][Ii][Ff][Ii][Ee][Dd]|[Tt][Rr][Aa][Dd][Ii][Tt][Ii][Oo][Nn][Aa][Ll]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Rr][Uu][Bb][Yy]|[Ss][Uu][Bb]|[Ss][Uu][Pp][Ee][Rr]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ff][Oo][Rr][Mm][Ss]|[Ss][Tt][Yy][Ll][Ii][Ss][Tt][Ii][Cc]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Ss][Tt][Yy][Ll][Ee][Ss][Ee][Tt]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)|[Cc][Hh][Aa][Rr][Aa][Cc][Tt][Ee][Rr]-[Vv][Aa][Rr][Ii][Aa][Nn][Tt]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)|[Ss][Ww][Aa][Ss][Hh]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Oo][Rr][Nn][Aa][Mm][Ee][Nn][Tt][Ss]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Aa][Nn][Nn][Oo][Tt][Aa][Tt][Ii][Oo][Nn]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\))(?:\s+(?:[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Nn][Oo]-[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Uu][Nn][Ii][Cc][Aa][Ss][Ee]|[Tt][Ii][Tt][Ll][Ii][Nn][Gg]-[Cc][Aa][Pp][Ss]|[Ll][Ii][Nn][Ii][Nn][Gg]-[Nn][Uu][Mm][Ss]|[Oo][Ll][Dd][Ss][Tt][Yy][Ll][Ee]-[Nn][Uu][Mm][Ss]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Nn][Uu][Mm][Ss]|[Tt][Aa][Bb][Uu][Ll][Aa][Rr]-[Nn][Uu][Mm][Ss]|[Dd][Ii][Aa][Gg][Oo][Nn][Aa][Ll]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Ss][Tt][Aa][Cc][Kk][Ee][Dd]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Oo][Rr][Dd][Ii][Nn][Aa][Ll]|[Ss][Ll][Aa][Ss][Hh][Ee][Dd]-[Zz][Ee][Rr][Oo]|[Jj][Ii][Ss]78|[Jj][Ii][Ss]83|[Jj][Ii][Ss]90|[Jj][Ii][Ss]04|[Ss][Ii][Mm][Pp][Ll][Ii][Ff][Ii][Ee][Dd]|[Tt][Rr][Aa][Dd][Ii][Tt][Ii][Oo][Nn][Aa][Ll]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Rr][Uu][Bb][Yy]|[Ss][Uu][Bb]|[Ss][Uu][Pp][Ee][Rr]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ff][Oo][Rr][Mm][Ss]|[Ss][Tt][Yy][Ll][Ii][Ss][Tt][Ii][Cc]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Ss][Tt][Yy][Ll][Ee][Ss][Ee][Tt]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)|[Cc][Hh][Aa][Rr][Aa][Cc][Tt][Ee][Rr]-[Vv][Aa][Rr][Ii][Aa][Nn][Tt]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)|[Ss][Ww][Aa][Ss][Hh]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Oo][Rr][Nn][Aa][Mm][Ee][Nn][Tt][Ss]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Aa][Nn][Nn][Oo][Tt][Aa][Tt][Ii][Oo][Nn]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)))*))$
        /**
         * String weights MUST conform to CSS <font-weight-absolute>, <font-weight-relative>, or <font-weight-range> productions (css-fonts-4).
         */
        export type FontWeightString = string; // ^(?:[Bb][Oo][Ll][Dd][Ee][Rr]|[Ll][Ii][Gg][Hh][Tt][Ee][Rr]|(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?))(?:\s+(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?)))?)$
        /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */
        export interface Function {
            /**
             * Token types §value, §filter tokens, and §easing use function identifiers aligned with CSS grammars and vendor-qualified variants.
             * Function identifier
             * Function name such as calc, clamp, or platform-specific identifiers per Token types §value.
             */
            fn: string; // ^[a-z][a-z0-9-]*(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)*$
            /**
             * Token types §value: parameters MAY be omitted when the referenced grammar takes no arguments; omitted parameters default to an empty array.
             * Function parameters
             * Ordered list of literals, references, nested functions, or arrays per Token types §value. When omitted, consumers treat the list as empty per Token types §value.
             */
            parameters?: FunctionParameter[];
        }
        /**
         * Token types §value: parameters MAY include literals, $ref aliases, nested functions, or arrays.
         * Function parameter
         * Literal, reference, nested function, array, or object argument accepted by function expressions per Token types §value.
         */
        export type FunctionParameter = /**
         * Token types §value: parameters MAY include literals, $ref aliases, nested functions, or arrays.
         * Function parameter
         * Literal, reference, nested function, array, or object argument accepted by function expressions per Token types §value.
         */ string | number | boolean | null | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function | /**
         * Token types §value: parameters MAY include literals, $ref aliases, nested functions, or arrays.
         * Function parameter
         * Literal, reference, nested function, array, or object argument accepted by function expressions per Token types §value.
         */ FunctionParameter[] | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | void;
        export interface Gradient {
            /**
             * Token types §gradient tokens: gradientType MUST be linear, radial, or conic matching CSS Images Module Level 4 gradient functions and mapping to CAGradientLayer.type or Android gradient shader constructors.
             * Gradient function
             * Gradient function name such as linear, radial, or conic per Token types §gradient tokens.
             */
            gradientType: "linear" | "radial" | "conic";
            /**
             * Represents the CSS <color-stop-list> grammar and corresponding native stop arrays.
             */
            stops: [
                {
                    position: number | /**
                     * Token types §gradient tokens and css-images-4: stop positions expressed as strings MUST be a single <length-percentage> or a pair separated by ASCII whitespace.
                     * Color stop length string
                     * CSS <color-stop-length> token composed of one or two <length-percentage> entries per Token types §gradient tokens.
                     * example:
                     * 0%
                     * calc(50% - 10px)
                     * var(--stop, 25%)
                     */ ColorStopLengthString /* ^(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+))(?:\s+(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+)))?$ */;
                    hint?: number | /**
                     * Token types §gradient tokens and css-images-4: hint strings MUST be a solitary <length-percentage> expression without an optional second stop.
                     * Color hint length string
                     * CSS <color-hint> token serialized as a single <length-percentage> entry per Token types §gradient tokens.
                     * example:
                     * 25%
                     * calc(10% + 2rem)
                     * var(--hint)
                     */ ColorHintLengthString /* ^(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+))$ */;
                    color: ColorReference;
                },
                {
                    position: number | /**
                     * Token types §gradient tokens and css-images-4: stop positions expressed as strings MUST be a single <length-percentage> or a pair separated by ASCII whitespace.
                     * Color stop length string
                     * CSS <color-stop-length> token composed of one or two <length-percentage> entries per Token types §gradient tokens.
                     * example:
                     * 0%
                     * calc(50% - 10px)
                     * var(--stop, 25%)
                     */ ColorStopLengthString /* ^(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+))(?:\s+(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+)))?$ */;
                    hint?: number | /**
                     * Token types §gradient tokens and css-images-4: hint strings MUST be a solitary <length-percentage> expression without an optional second stop.
                     * Color hint length string
                     * CSS <color-hint> token serialized as a single <length-percentage> entry per Token types §gradient tokens.
                     * example:
                     * 25%
                     * calc(10% + 2rem)
                     * var(--hint)
                     */ ColorHintLengthString /* ^(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+))$ */;
                    color: ColorReference;
                },
                ...{
                    position: number | /**
                     * Token types §gradient tokens and css-images-4: stop positions expressed as strings MUST be a single <length-percentage> or a pair separated by ASCII whitespace.
                     * Color stop length string
                     * CSS <color-stop-length> token composed of one or two <length-percentage> entries per Token types §gradient tokens.
                     * example:
                     * 0%
                     * calc(50% - 10px)
                     * var(--stop, 25%)
                     */ ColorStopLengthString /* ^(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+))(?:\s+(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+)))?$ */;
                    hint?: number | /**
                     * Token types §gradient tokens and css-images-4: hint strings MUST be a solitary <length-percentage> expression without an optional second stop.
                     * Color hint length string
                     * CSS <color-hint> token serialized as a single <length-percentage> entry per Token types §gradient tokens.
                     * example:
                     * 25%
                     * calc(10% + 2rem)
                     * var(--hint)
                     */ ColorHintLengthString /* ^(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+))$ */;
                    color: ColorReference;
                }[]
            ];
            /**
             * Gradient angle
             * Linear gradient line orientation expressed as a CSS <angle> string or numeric degrees per Token types §gradient tokens.
             */
            angle?: 
            /**
             * Token types §gradient tokens: string angles MUST be a CSS <angle> with units or the 'to <side-or-corner>' grammar (css-images-4).
             * Gradient line orientation
             * CSS linear-gradient line syntax accepting an <angle> or to <side-or-corner> keyword per Token types §gradient tokens.
             * example:
             * 45deg
             * to top right
             * 0
             * -0.25turn
             */
            /**
             * Gradient angle
             * Linear gradient line orientation expressed as a CSS <angle> string or numeric degrees per Token types §gradient tokens.
             */ GradientLineAngle /* ^(?:[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:[Dd][Ee][Gg]|[Gg][Rr][Aa][Dd]|[Rr][Aa][Dd]|[Tt][Uu][Rr][Nn])|[-+]?(?:0+(?:\.0+)?|\.0+)|[Tt][Oo]\s+(?:(?:[Ll][Ee][Ff][Tt]|[Rr][Ii][Gg][Hh][Tt])(?:\s+(?:[Tt][Oo][Pp]|[Bb][Oo][Tt][Tt][Oo][Mm]))?|(?:[Tt][Oo][Pp]|[Bb][Oo][Tt][Tt][Oo][Mm])(?:\s+(?:[Ll][Ee][Ff][Tt]|[Rr][Ii][Gg][Hh][Tt]))?))$ */ | number;
            center?: {
                x: number;
                y: number;
            } | /**
             * Token types §gradient tokens: centre strings MUST follow the CSS <position> grammar used by radial-gradient() and conic-gradient() (css-images-4).
             * Gradient position
             * CSS <position> tokens composed of keywords, <length-percentage>, or calc-style functions per Token types §gradient tokens.
             * example:
             * center 25%
             * left top
             * calc(100% - 0.25rem) center
             * calc(min(10%, max(5%, var(--x))) + 2em) 50%
             */ GradientPosition /* ^(?:(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+)|(?:[Cc][Ee][Nn][Tt][Ee][Rr]|[Ll][Ee][Ff][Tt]|[Rr][Ii][Gg][Hh][Tt]|[Tt][Oo][Pp]|[Bb][Oo][Tt][Tt][Oo][Mm])))(?:\s+(?:(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+)|(?:[Cc][Ee][Nn][Tt][Ee][Rr]|[Ll][Ee][Ff][Tt]|[Rr][Ii][Gg][Hh][Tt]|[Tt][Oo][Pp]|[Bb][Oo][Tt][Tt][Oo][Mm])))){0,3}$ */;
            /**
             * Token types §gradient tokens: shape MUST be the <rg-ending-shape> keyword circle or ellipse (css-images-3).
             * Gradient ending shape
             * Radial gradient ending shape keyword such as circle or ellipse per Token types §gradient tokens.
             * example:
             * circle
             * ellipse
             */
            shape?: string; // ^(?:[Cc][Ii][Rr][Cc][Ll][Ee]|[Ee][Ll][Ll][Ii][Pp][Ss][Ee])$
        }
        /**
         * Token types §gradient tokens: shape MUST be the <rg-ending-shape> keyword circle or ellipse (css-images-3).
         * Radial gradient ending shape
         * CSS radial-gradient() ending shape keyword per Token types §gradient tokens.
         * example:
         * circle
         * ellipse
         */
        export type GradientEndingShape = string; // ^(?:[Cc][Ii][Rr][Cc][Ll][Ee]|[Ee][Ll][Ll][Ii][Pp][Ss][Ee])$
        /**
         * Token types §gradient tokens: string angles MUST be a CSS <angle> with units or the 'to <side-or-corner>' grammar (css-images-4).
         * Gradient line orientation
         * CSS linear-gradient line syntax accepting an <angle> or to <side-or-corner> keyword per Token types §gradient tokens.
         * example:
         * 45deg
         * to top right
         * 0
         * -0.25turn
         */
        export type GradientLineAngle = string; // ^(?:[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:[Dd][Ee][Gg]|[Gg][Rr][Aa][Dd]|[Rr][Aa][Dd]|[Tt][Uu][Rr][Nn])|[-+]?(?:0+(?:\.0+)?|\.0+)|[Tt][Oo]\s+(?:(?:[Ll][Ee][Ff][Tt]|[Rr][Ii][Gg][Hh][Tt])(?:\s+(?:[Tt][Oo][Pp]|[Bb][Oo][Tt][Tt][Oo][Mm]))?|(?:[Tt][Oo][Pp]|[Bb][Oo][Tt][Tt][Oo][Mm])(?:\s+(?:[Ll][Ee][Ff][Tt]|[Rr][Ii][Gg][Hh][Tt]))?))$
        /**
         * Token types §gradient tokens: centre strings MUST follow the CSS <position> grammar used by radial-gradient() and conic-gradient() (css-images-4).
         * Gradient position
         * CSS <position> tokens composed of keywords, <length-percentage>, or calc-style functions per Token types §gradient tokens.
         * example:
         * center 25%
         * left top
         * calc(100% - 0.25rem) center
         * calc(min(10%, max(5%, var(--x))) + 2em) 50%
         */
        export type GradientPosition = string; // ^(?:(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+)|(?:[Cc][Ee][Nn][Tt][Ee][Rr]|[Ll][Ee][Ff][Tt]|[Rr][Ii][Gg][Hh][Tt]|[Tt][Oo][Pp]|[Bb][Oo][Tt][Tt][Oo][Mm])))(?:\s+(?:(?:(?:[Cc][Aa][Ll][Cc]|[Mm][Ii][Nn]|[Mm][Aa][Xx]|[Cc][Ll][Aa][Mm][Pp]|[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\)|[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*)|[-+]?(?:0+(?:\.0+)?|\.0+)|(?:[Cc][Ee][Nn][Tt][Ee][Rr]|[Ll][Ee][Ff][Tt]|[Rr][Ii][Gg][Hh][Tt]|[Tt][Oo][Pp]|[Bb][Oo][Tt][Tt][Oo][Mm])))){0,3}$
        /**
         * Token types §gradient tokens and §value: gradient tokens MAY embed direct values, $ref aliases, or functions.
         * Gradient value entry
         * Literal gradient payload, alias, or computed expression per Token types §gradient tokens.
         */
        export type GradientValueEntry = /**
         * Token types §gradient tokens and §value: gradient tokens MAY embed direct values, $ref aliases, or functions.
         * Gradient value entry
         * Literal gradient payload, alias, or computed expression per Token types §gradient tokens.
         */ Gradient | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Gradient fallback list
         * Ordered fallback list of gradient values evaluated per Token types §value.
         */
        export type GradientValueFallback = [
            /**
             * Token types §gradient tokens and §value: gradient tokens MAY embed direct values, $ref aliases, or functions.
             * Gradient value entry
             * Literal gradient payload, alias, or computed expression per Token types §gradient tokens.
             */
            GradientValueEntry,
            ...GradientValueEntry[]
        ];
        /**
         * Metadata table: $hash MUST NOT contain whitespace.
         * Hash string
         * Stable identifier with no whitespace per Metadata §metadata.
         */
        export type HashString = string; // ^\S+$
        export interface LengthDimension {
            dimensionType: "length";
            value: number;
            /**
             * MUST conform to CSS <length> or <percentage> (css-values-4) or native point/density-independent units (IOS-POINTS, ANDROID-DP-SP).
             */
            unit: string; // ^(?:%|[A-Za-z][A-Za-z0-9-]*)$
            /**
             * When true, MUST follow Dynamic Type (IOS-DYNAMIC-TYPE) and Android scale-independent behaviour (ANDROID-DP-SP).
             * Whether the value scales with the user's font settings.
             */
            fontScale?: boolean;
        }
        /**
         * Token types §dimension: length measurements MAY be serialized inline or referenced via $ref.
         * Length dimension literal or alias
         * Length measurement or $ref alias per Token types §dimension (length) and Format and serialisation §$ref.
         */
        export type LengthDimensionReference = /**
         * Token types §dimension: length measurements MAY be serialized inline or referenced via $ref.
         * Length dimension literal or alias
         * Length measurement or $ref alias per Token types §dimension (length) and Format and serialisation §$ref.
         */ LengthDimension | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference;
        /**
         * Metadata table: $lastUsed requires $usageCount > 0; $usageCount = 0 forbids $lastUsed.
         * Lifecycle telemetry requirements
         * Ensures $lastUsed timestamps and $usageCount counters follow Metadata §table requirements.
         */
        export type LifecycleMetadata = any;
        /**
         * Typography §line-height: value MUST be a non-negative ratio or font-dimension measurement.
         * Line height value
         * Unitless ratio or font-dimension measurement describing baseline spacing per Typography §line-height.
         */
        export type LineHeight = /**
         * Typography §line-height: value MUST be a non-negative ratio or font-dimension measurement.
         * Line height value
         * Unitless ratio or font-dimension measurement describing baseline spacing per Typography §line-height.
         */ number | /**
         * Typography §line-height: value MUST be a non-negative ratio or font-dimension measurement.
         * Line height value
         * Unitless ratio or font-dimension measurement describing baseline spacing per Typography §line-height.
         */ ({
            dimensionType: "length";
            value: number;
            /**
             * MUST conform to CSS <length> or <percentage> (css-values-4) or native point/density-independent units (IOS-POINTS, ANDROID-DP-SP).
             */
            unit: string; // ^(?:%|[A-Za-z][A-Za-z0-9-]*)$
            /**
             * When true, MUST follow Dynamic Type (IOS-DYNAMIC-TYPE) and Android scale-independent behaviour (ANDROID-DP-SP).
             * Whether the value scales with the user's font settings.
             */
            fontScale?: boolean;
        } | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference);
        /**
         * Typography §line-height and Token types §value: line-height tokens MAY embed direct values, $ref aliases, or functions.
         * Line-height value entry
         * Ratio, font-dimension, alias, or computed expression per Typography §line-height.
         */
        export type LineHeightValueEntry = 
        /**
         * Typography §line-height: value MUST be a non-negative ratio or font-dimension measurement.
         * Line height value
         * Unitless ratio or font-dimension measurement describing baseline spacing per Typography §line-height.
         */
        /**
         * Typography §line-height and Token types §value: line-height tokens MAY embed direct values, $ref aliases, or functions.
         * Line-height value entry
         * Ratio, font-dimension, alias, or computed expression per Typography §line-height.
         */ LineHeight | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Line-height fallback list
         * Ordered fallback list of line-height values evaluated per Token types §value.
         */
        export type LineHeightValueFallback = [
            /**
             * Typography §line-height and Token types §value: line-height tokens MAY embed direct values, $ref aliases, or functions.
             * Line-height value entry
             * Ratio, font-dimension, alias, or computed expression per Typography §line-height.
             */
            LineHeightValueEntry,
            ...LineHeightValueEntry[]
        ];
        /**
         * Metadata §metadata table.
         * Metadata members
         * Optional metadata fields defined in Metadata §metadata applied to tokens and collections.
         */
        export interface MetadataMembers {
            /**
             * Metadata table: $description is optional free-form text.
             * Description
             * Human-readable explanation preserved for design intent per Metadata §metadata.
             */
            $description?: string;
            /**
             * Format and serialisation §$extensions.
             * Extensions
             * Namespaced metadata preserved by consumers per Format and serialisation §$extensions.
             */
            $extensions?: {
                [name: string]: any;
            };
            /**
             * Metadata table: $deprecated MAY be a boolean or an object with $replacement.
             * Deprecation metadata
             * Boolean indicator or replacement pointer per Metadata §metadata.
             */
            $deprecated?: /**
             * Metadata table: $deprecated MAY be a boolean or an object with $replacement.
             * Deprecation metadata
             * Boolean indicator or replacement pointer per Metadata §metadata.
             */ boolean | {
                /**
                 * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
                 * Replacement token pointer
                 * Pointer to the successor token that MUST resolve to the same $type per Metadata §metadata.
                 */
                $replacement: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
            };
            /**
             * Metadata table: $lastModified establishes the lower bound for $lastUsed.
             * Last modified timestamp
             * RFC 3339 date-time recording governance actions per Metadata §metadata.
             */
            $lastModified?: string; // date-time
            /**
             * Metadata table: $lastUsed MUST NOT precede $lastModified and requires $usageCount > 0.
             * Last used timestamp
             * RFC 3339 date-time capturing usage telemetry per Metadata §metadata.
             */
            $lastUsed?: string; // date-time
            /**
             * Metadata table: $usageCount records adoption and pairs with $lastUsed when greater than zero.
             * Usage count
             * Non-negative adoption counter per Metadata §metadata.
             */
            $usageCount?: number;
            /**
             * Metadata table: $author MUST be a non-empty trimmed string.
             * Author
             * Contributor name without leading or trailing whitespace per Metadata §metadata.
             */
            $author?: string; // ^(?!\s)(?:.*\S)?$
            /**
             * Metadata table: $tags MUST be an array of trimmed, unique strings.
             * Tags
             * Unique classification strings free of surrounding whitespace per Metadata §metadata.
             */
            $tags?: TrimmedString /* ^(?!\s)(?:.*\S)?$ */[];
            /**
             * Metadata table: $hash MUST be non-empty and contain no whitespace.
             * Hash
             * Stable identifier without whitespace for change tracking per Metadata §metadata.
             */
            $hash?: string; // ^\S+$
        }
        namespace MetadataMembers {
            namespace Properties {
                /**
                 * Metadata table: $author MUST be a non-empty trimmed string.
                 * Author
                 * Contributor name without leading or trailing whitespace per Metadata §metadata.
                 */
                export type $Author = string; // ^(?!\s)(?:.*\S)?$
                /**
                 * Metadata table: $deprecated MAY be a boolean or an object with $replacement.
                 * Deprecation metadata
                 * Boolean indicator or replacement pointer per Metadata §metadata.
                 */
                export type $Deprecated = /**
                 * Metadata table: $deprecated MAY be a boolean or an object with $replacement.
                 * Deprecation metadata
                 * Boolean indicator or replacement pointer per Metadata §metadata.
                 */ boolean | {
                    /**
                     * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
                     * Replacement token pointer
                     * Pointer to the successor token that MUST resolve to the same $type per Metadata §metadata.
                     */
                    $replacement: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
                };
                /**
                 * Metadata table: $description is optional free-form text.
                 * Description
                 * Human-readable explanation preserved for design intent per Metadata §metadata.
                 */
                export type $Description = string;
                /**
                 * Format and serialisation §$extensions.
                 * Extensions
                 * Namespaced metadata preserved by consumers per Format and serialisation §$extensions.
                 */
                export interface $Extensions {
                    [name: string]: any;
                }
                /**
                 * Metadata table: $hash MUST be non-empty and contain no whitespace.
                 * Hash
                 * Stable identifier without whitespace for change tracking per Metadata §metadata.
                 */
                export type $Hash = string; // ^\S+$
                /**
                 * Metadata table: $lastModified establishes the lower bound for $lastUsed.
                 * Last modified timestamp
                 * RFC 3339 date-time recording governance actions per Metadata §metadata.
                 */
                export type $LastModified = string; // date-time
                /**
                 * Metadata table: $lastUsed MUST NOT precede $lastModified and requires $usageCount > 0.
                 * Last used timestamp
                 * RFC 3339 date-time capturing usage telemetry per Metadata §metadata.
                 */
                export type $LastUsed = string; // date-time
                /**
                 * Metadata table: $tags MUST be an array of trimmed, unique strings.
                 * Tags
                 * Unique classification strings free of surrounding whitespace per Metadata §metadata.
                 */
                export type $Tags = TrimmedString /* ^(?!\s)(?:.*\S)?$ */[];
                /**
                 * Metadata table: $usageCount records adoption and pairs with $lastUsed when greater than zero.
                 * Usage count
                 * Non-negative adoption counter per Metadata §metadata.
                 */
                export type $UsageCount = number;
            }
        }
        export interface Motion {
            /**
             * MUST name a platform transform such as css.translate, ios.catransform3d.rotate, or android.viewpropertyanimator.scalex as defined by CSS Transforms Module Level 2 (css-transforms-2#transform-functions), Core Animation (IOS-CGAFFINETRANSFORM, IOS-CATRANSFORM3D, IOS-CAKEYFRAMEANIMATION), and Android animation APIs (ANDROID-VIEWPROPERTYANIMATOR, ANDROID-OBJECTANIMATOR).
             * Motion transform identifier
             * Platform-qualified transform such as css.translate, ios.catransform3d.rotate, or android.viewpropertyanimator.scalex.
             */
            motionType: string; // ^(?:css|ios|android)(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)+$
            /**
             * Members MUST align with the grammar of the referenced transform function.
             */
            parameters: {
                [key: string]: any;
            };
        }
        /**
         * MUST evaluate to a CSS <angle> (css-values-4#angles) compatible with Core Animation and Android rotation APIs.
         */
        export type MotionAngle = /* MUST evaluate to a CSS <angle> (css-values-4#angles) compatible with Core Animation and Android rotation APIs. */ /**
         * Token types §dimension: angle measurements MAY be serialized inline or referenced via $ref.
         * Angle dimension literal or alias
         * Angle measurement or $ref alias per Token types §dimension (angle) and Format and serialisation §$ref.
         */ AngleDimensionReference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * MUST evaluate to a CSS <length-percentage> (css-values-4#typedef-length-percentage) or equivalent platform distance for translation and path coordinates.
         */
        export type MotionLength = /* MUST evaluate to a CSS <length-percentage> (css-values-4#typedef-length-percentage) or equivalent platform distance for translation and path coordinates. */ /**
         * Token types §dimension: length measurements MAY be serialized inline or referenced via $ref.
         * Length dimension literal or alias
         * Length measurement or $ref alias per Token types §dimension (length) and Format and serialisation §$ref.
         */ LengthDimensionReference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Normalised fractions (0-1) representing transform-origin percentages, CALayer.anchorPoint, and View#setPivotX/Y.
         */
        export type MotionOrigin = /* Normalised fractions (0-1) representing transform-origin percentages, CALayer.anchorPoint, and View#setPivotX/Y. */ {
            x: number;
            y?: number;
            z?: number;
        } | {
            y: number;
            x?: number;
            z?: number;
        } | {
            z: number;
            x?: number;
            y?: number;
        };
        export interface MotionPathPoint {
            /**
             * Normalised progress matching CAKeyframeAnimation.keyTimes and ObjectAnimator fractions.
             */
            time: number;
            position: MotionPathPosition;
            easing?: Pointer /* ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$ */;
        }
        /**
         * Each axis resolves to <length-percentage> coordinates evaluated along the referenced path geometry.
         */
        export type MotionPathPosition = /* Each axis resolves to <length-percentage> coordinates evaluated along the referenced path geometry. */ {
            x: MotionLength;
            y?: MotionLength;
            z?: MotionLength;
        } | {
            y: MotionLength;
            x?: MotionLength;
            z?: MotionLength;
        } | {
            z: MotionLength;
            x?: MotionLength;
            y?: MotionLength;
        };
        /**
         * Non-negative multiplier matching CSS scale() arguments and native scale factors; negative multipliers remain invalid.
         */
        export type MotionScaleFactor = number;
        /**
         * Token types §motion tokens and §value: motion tokens MAY embed direct values, $ref aliases, or functions.
         * Motion value entry
         * Literal motion payload, alias, or computed expression per Token types §motion tokens.
         */
        export type MotionValueEntry = /**
         * Token types §motion tokens and §value: motion tokens MAY embed direct values, $ref aliases, or functions.
         * Motion value entry
         * Literal motion payload, alias, or computed expression per Token types §motion tokens.
         */ Motion | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Motion fallback list
         * Ordered fallback list of motion values evaluated per Token types §value.
         */
        export type MotionValueFallback = [
            /**
             * Token types §motion tokens and §value: motion tokens MAY embed direct values, $ref aliases, or functions.
             * Motion value entry
             * Literal motion payload, alias, or computed expression per Token types §motion tokens.
             */
            MotionValueEntry,
            ...MotionValueEntry[]
        ];
        /**
         * Token types §value, §filter tokens, and §easing use function identifiers aligned with CSS grammars and vendor-qualified variants.
         * Function identifier
         * Lower-case identifier optionally namespaced with dot-separated segments for CSS and platform functions.
         */
        export type NamespacedFunctionIdentifier = string; // ^[a-z][a-z0-9-]*(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)*$
        /**
         * Architecture and model §tokens-and-collections.
         * Token or collection node
         * Tree node that is either a token or a collection per Architecture and model §tokens-and-collections.
         */
        export type Node = 
        /**
         * Terminology §token and Format and serialisation §$ref.
         * Design token
         * Object declaring either $value or $ref along with optional metadata per Terminology §token and Format and serialisation §$ref.
         */
        /**
         * Architecture and model §tokens-and-collections.
         * Token or collection node
         * Tree node that is either a token or a collection per Architecture and model §tokens-and-collections.
         */ Token | /**
         * Architecture and model §tokens-and-collections.
         * Token collection
         * Object without $value whose non-reserved members are tokens or collections per Architecture and model §tokens-and-collections.
         */ Collection;
        /**
         * Token types §value: fallback arrays MUST provide at least one entry.
         * Non-empty array
         * Array containing at least one candidate per Token types §value fallback semantics.
         */
        export type NonEmptyArray = any[];
        export interface Opacity {
            /**
             * MUST name a platform opacity property such as css.opacity (css-color-4#propdef-opacity), ios.uiview.alpha (IOS-UIVIEW-ALPHA), ios.layer.opacity (IOS-CALAYER), or android.view.alpha (ANDROID-VIEW-ALPHA).
             * Opacity context identifier
             * Platform-qualified opacity context such as css.opacity, ios.uiview.alpha, or android.view.alpha.
             */
            opacityType: string; // ^(?:css|ios|android)(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)+$
            value: number | string /* ^(?:[-+]?(?:\d+(?:\.\d+)?|\.\d+)%?|[A-Za-z-]+\(.+\))$ */;
        }
        /**
         * Token types §opacity and §value: opacity tokens MAY embed direct values, $ref aliases, or functions.
         * Opacity value entry
         * Numeric opacity, alias, or computed expression per Token types §opacity.
         */
        export type OpacityValueEntry = /**
         * Token types §opacity and §value: opacity tokens MAY embed direct values, $ref aliases, or functions.
         * Opacity value entry
         * Numeric opacity, alias, or computed expression per Token types §opacity.
         */ Opacity | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Opacity fallback list
         * Ordered fallback list of opacity values evaluated per Token types §value.
         */
        export type OpacityValueFallback = [
            /**
             * Token types §opacity and §value: opacity tokens MAY embed direct values, $ref aliases, or functions.
             * Opacity value entry
             * Numeric opacity, alias, or computed expression per Token types §opacity.
             */
            OpacityValueEntry,
            ...OpacityValueEntry[]
        ];
        /**
         * Theming and overrides §$overrides.
         * Override rule
         * Contextual substitution entry evaluated against $when conditions per Theming and overrides §$overrides.
         */
        export type Override = /**
         * Theming and overrides §$overrides.
         * Override rule
         * Contextual substitution entry evaluated against $when conditions per Theming and overrides §$overrides.
         */ {
            /**
             * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
             * Override reference
             * Pointer to the replacement token per Theming and overrides §$overrides.
             */
            $ref: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
        } | {
            $value: any;
            /**
             * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
             * Override reference
             * Pointer to the replacement token per Theming and overrides §$overrides.
             */
            $ref?: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
        } | {
            $fallback: any;
            /**
             * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
             * Override reference
             * Pointer to the replacement token per Theming and overrides §$overrides.
             */
            $ref?: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
        };
        /**
         * Theming and overrides §$overrides.
         * Override rule members
         * Shared override members applied to $overrides entries per Theming and overrides §$overrides.
         */
        export interface OverrideCore {
            /**
             * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
             * Target token
             * Pointer to the token being overridden per Theming and overrides §$overrides.
             */
            $token: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
            /**
             * Override contexts MUST declare at least one condition per Theming and overrides §$overrides.
             * Override conditions
             * Context map describing when the override applies per Theming and overrides §$overrides.
             */
            $when: {
                [key: string]: any;
            };
            /**
             * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
             * Override reference
             * Pointer to the replacement token per Theming and overrides §$overrides.
             */
            $ref?: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
            /**
             * Inline override values must conform to the target token's $type.
             * Inline override value
             * Direct replacement that MUST satisfy the overridden token's $type per Theming and overrides §$overrides.
             */
            $value?: any;
            /**
             * Theming and overrides §$overrides: $fallback MAY be a single entry or an array processed sequentially.
             * Fallback chain
             * Single fallback object or array evaluated when primary override resolution fails per Theming and overrides §$overrides.
             */
            $fallback?: 
            /**
             * Theming and overrides §$overrides: fallback entries mirror override semantics.
             * Fallback entry
             * Single fallback candidate containing a $ref or inline $value per Theming and overrides §$overrides.
             */
            /**
             * Theming and overrides §$overrides: $fallback MAY be a single entry or an array processed sequentially.
             * Fallback chain
             * Single fallback object or array evaluated when primary override resolution fails per Theming and overrides §$overrides.
             */ FallbackEntry | [
                /**
                 * Theming and overrides §$overrides: fallback entries mirror override semantics.
                 * Fallback entry
                 * Single fallback candidate containing a $ref or inline $value per Theming and overrides §$overrides.
                 */
                FallbackEntry,
                ...FallbackEntry[]
            ];
        }
        /**
         * Token types §cursor, §filter tokens, §opacity, §duration, §z-index, §motion tokens, Typography §font, and §font-face require css/ios/android-qualified identifiers for context selection.
         * Platform-qualified identifier
         * Lower-case dot-separated identifier prefixed with css, ios, or android per platform-qualified token members.
         */
        export type PlatformIdentifier = string; // ^(?:css|ios|android)(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)+$
        /**
         * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
         * DTIF pointer reference
         * JSON Pointer string optionally prefixed by a relative path or HTTP(S) URI with a fragment per Format and serialisation §$ref.
         */
        export type Pointer = void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
        /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */
        export interface Reference {
            /**
             * Percent-encoded or mixed-encoding .. segments after directory boundaries are rejected (Format and serialisation §$ref step 1).
             * Alias target
             * Pointer to the referenced token per Format and serialisation §$ref.
             */
            $ref: void; // ^(?:#|[^#]+#)(?:\/[^~\/]*(?:~[01][^~\/]*)*)*$
        }
        export type Shadow = ShadowLayer | [
            ShadowLayer,
            ...ShadowLayer[]
        ];
        export interface ShadowLayer {
            /**
             * MUST identify the rendering context defined by CSS <shadow> grammars, UIKit CALayer/NSShadow APIs, or Android View/Paint shadow documentation (e.g. css.box-shadow, css.text-shadow, css.filter.drop-shadow, ios.layer, ios.text, android.view.elevation).
             * Shadow context identifier
             * Rendering surface identifier such as css.box-shadow, css.text-shadow, ios.layer, or android.view.elevation.
             */
            shadowType: string; // ^[a-z][a-z0-9-]*(?:\.[a-z0-9-]+)*$
            /**
             * Horizontal offset MUST conform to CSS <length> or platform-native units such as points (pt) and density-independent pixels (dp).
             */
            offsetX: LengthDimensionReference;
            /**
             * Vertical offset MUST conform to CSS <length> or platform-native units such as points (pt) and density-independent pixels (dp).
             */
            offsetY: LengthDimensionReference;
            /**
             * Blur radius MUST match the <length> position in the CSS <shadow> production or equivalent CALayer.shadowRadius / Paint#setShadowLayer radius semantics.
             * Shadow blur radius
             * Length measurement describing blur spread per Token types §shadow tokens.
             */
            blur: /**
             * Blur radius MUST match the <length> position in the CSS <shadow> production or equivalent CALayer.shadowRadius / Paint#setShadowLayer radius semantics.
             * Shadow blur radius
             * Length measurement describing blur spread per Token types §shadow tokens.
             */ LengthDimension | /**
             * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
             * Pointer alias
             * Object aliasing another token via $ref per Token types §value.
             */ Reference;
            /**
             * Optional spread MUST follow the final <length> of CSS <shadow> and is realised via CALayer.shadowPath or Android outline inflation.
             */
            spread?: LengthDimensionReference;
            /**
             * Shadow colour MUST conform to CSS <color> values and map to CGColor / Android colour integers.
             */
            color: ColorReference;
        }
        /**
         * Token types §shadow tokens and §value: shadow tokens MAY embed direct values, $ref aliases, or functions.
         * Shadow value entry
         * Literal shadow payload, alias, or computed expression per Token types §shadow tokens.
         */
        export type ShadowValueEntry = /**
         * Token types §shadow tokens and §value: shadow tokens MAY embed direct values, $ref aliases, or functions.
         * Shadow value entry
         * Literal shadow payload, alias, or computed expression per Token types §shadow tokens.
         */ Shadow | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        export interface StrokeStyle {
            /**
             * Sequence of dash and gap lengths MUST follow SVG stroke-dasharray semantics and map to CAShapeLayer.lineDashPattern and Android DashPathEffect intervals.
             */
            dashArray?: [
                (number | /**
                 * Token types §dimension: length measurements MAY be serialized inline or referenced via $ref.
                 * Length dimension literal or alias
                 * Length measurement or $ref alias per Token types §dimension (length) and Format and serialisation §$ref.
                 */ LengthDimensionReference),
                ...(number | /**
                 * Token types §dimension: length measurements MAY be serialized inline or referenced via $ref.
                 * Length dimension literal or alias
                 * Length measurement or $ref alias per Token types §dimension (length) and Format and serialisation §$ref.
                 */ LengthDimensionReference)[]
            ];
            dashOffset?: number | /**
             * Token types §dimension: length measurements MAY be serialized inline or referenced via $ref.
             * Length dimension literal or alias
             * Length measurement or $ref alias per Token types §dimension (length) and Format and serialisation §$ref.
             */ LengthDimensionReference;
            /**
             * Line caps MUST match the <stroke-linecap> keywords butt, round, or square defined by SVG and Canvas 2D.
             */
            lineCap?: "butt" | "round" | "square";
            /**
             * Line joins MUST match the <stroke-linejoin> keywords miter, round, or bevel defined by SVG and Canvas 2D.
             */
            lineJoin?: "miter" | "round" | "bevel";
            /**
             * Miter limits MUST be >= 1 following SVG stroke-miterlimit and CanvasRenderingContext2D.miterLimit semantics.
             */
            miterLimit?: number;
        }
        /**
         * Token types §stroke-style tokens and §value: strokeStyle tokens MAY embed direct values, $ref aliases, or functions.
         * Stroke style value entry
         * Literal stroke-style payload, alias, or computed expression per Token types §stroke-style tokens.
         */
        export type StrokeStyleValueEntry = /**
         * Token types §stroke-style tokens and §value: strokeStyle tokens MAY embed direct values, $ref aliases, or functions.
         * Stroke style value entry
         * Literal stroke-style payload, alias, or computed expression per Token types §stroke-style tokens.
         */ StrokeStyle | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Stroke style fallback list
         * Ordered fallback list of stroke-style values evaluated per Token types §value.
         */
        export type StrokeStyleValueFallback = [
            /**
             * Token types §stroke-style tokens and §value: strokeStyle tokens MAY embed direct values, $ref aliases, or functions.
             * Stroke style value entry
             * Literal stroke-style payload, alias, or computed expression per Token types §stroke-style tokens.
             */
            StrokeStyleValueEntry,
            ...StrokeStyleValueEntry[]
        ];
        /**
         * Metadata table: $tags MUST contain unique trimmed strings.
         * Tag list
         * Array of unique trimmed classification strings per Metadata §metadata.
         */
        export type Tags = TrimmedString /* ^(?!\s)(?:.*\S)?$ */[];
        /**
         * Typography §text-decoration: serialised strings MUST follow the CSS text-decoration grammar, including named colours, system colours, calc()/var() functions, and <length-percentage> thickness values.
         * Text decoration shorthand
         * CSS text-decoration shorthand accepting line, style, colour, and thickness components per Typography §text-decoration and CSS Text Decoration Module Level 4.
         */
        export type TextDecorationShorthand = string; // ^(?:(?:[Ii][Nn][Hh][Ee][Rr][Ii][Tt]|[Ii][Nn][Ii][Tt][Ii][Aa][Ll]|[Uu][Nn][Ss][Ee][Tt]|[Rr][Ee][Vv][Ee][Rr][Tt](?:-[Ll][Aa][Yy][Ee][Rr])?)|(?:(?:(?:[Nn][Oo][Nn][Ee]|[Uu][Nn][Dd][Ee][Rr][Ll][Ii][Nn][Ee]|[Oo][Vv][Ee][Rr][Ll][Ii][Nn][Ee]|[Ll][Ii][Nn][Ee]-[Tt][Hh][Rr][Oo][Uu][Gg][Hh]|[Bb][Ll][Ii][Nn][Kk]|[Ss][Pp][Ee][Ll][Ll][Ii][Nn][Gg]-[Ee][Rr][Rr][Oo][Rr]|[Gg][Rr][Aa][Mm][Mm][Aa][Rr]-[Ee][Rr][Rr][Oo][Rr])|(?:[Ss][Oo][Ll][Ii][Dd]|[Dd][Oo][Uu][Bb][Ll][Ee]|[Dd][Oo][Tt][Tt][Ee][Dd]|[Dd][Aa][Ss][Hh][Ee][Dd]|[Ww][Aa][Vv][Yy])|(?:[Tt][Hh][Ii][Nn]|[Mm][Ee][Dd][Ii][Uu][Mm]|[Tt][Hh][Ii][Cc][Kk]|[Aa][Uu][Tt][Oo]|[Ff][Rr][Oo][Mm]-[Ff][Oo][Nn][Tt])|(?:[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*))|(?:[-+]?0+(?:\.0+)?)|(?:#(?:[0-9A-Fa-f]{3}|[0-9A-Fa-f]{4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8}))|(?:[A-Za-z][A-Za-z0-9-]*\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))|(?:[aA][cC][cC][eE][nN][tT][cC][oO][lL][oO][rR]|[aA][cC][cC][eE][nN][tT][cC][oO][lL][oO][rR][tT][eE][xX][tT]|[aA][cC][tT][iI][vV][eE][bB][oO][rR][dD][eE][rR]|[aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN]|[aA][cC][tT][iI][vV][eE][tT][eE][xX][tT]|[aA][lL][iI][cC][eE][bB][lL][uU][eE]|[aA][nN][tT][iI][qQ][uU][eE][wW][hH][iI][tT][eE]|[aA][pP][pP][wW][oO][rR][kK][sS][pP][aA][cC][eE]|[aA][qQ][uU][aA]|[aA][qQ][uU][aA][mM][aA][rR][iI][nN][eE]|[aA][zZ][uU][rR][eE]|[bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]|[bB][eE][iI][gG][eE]|[bB][iI][sS][qQ][uU][eE]|[bB][lL][aA][cC][kK]|[bB][lL][aA][nN][cC][hH][eE][dD][aA][lL][mM][oO][nN][dD]|[bB][lL][uU][eE]|[bB][lL][uU][eE][vV][iI][oO][lL][eE][tT]|[bB][rR][oO][wW][nN]|[bB][uU][rR][lL][yY][wW][oO][oO][dD]|[bB][uU][tT][tT][oO][nN][bB][oO][rR][dD][eE][rR]|[bB][uU][tT][tT][oO][nN][fF][aA][cC][eE]|[bB][uU][tT][tT][oO][nN][hH][iI][gG][hH][lL][iI][gG][hH][tT]|[bB][uU][tT][tT][oO][nN][sS][hH][aA][dD][oO][wW]|[bB][uU][tT][tT][oO][nN][tT][eE][xX][tT]|[cC][aA][dD][eE][tT][bB][lL][uU][eE]|[cC][aA][nN][vV][aA][sS]|[cC][aA][nN][vV][aA][sS][tT][eE][xX][tT]|[cC][aA][pP][tT][iI][oO][nN][tT][eE][xX][tT]|[cC][hH][aA][rR][tT][rR][eE][uU][sS][eE]|[cC][hH][oO][cC][oO][lL][aA][tT][eE]|[cC][oO][rR][aA][lL]|[cC][oO][rR][nN][fF][lL][oO][wW][eE][rR][bB][lL][uU][eE]|[cC][oO][rR][nN][sS][iI][lL][kK]|[cC][rR][iI][mM][sS][oO][nN]|[cC][uU][rR][rR][eE][nN][tT][cC][oO][lL][oO][rR]|[cC][yY][aA][nN]|[dD][aA][rR][kK][bB][lL][uU][eE]|[dD][aA][rR][kK][cC][yY][aA][nN]|[dD][aA][rR][kK][gG][oO][lL][dD][eE][nN][rR][oO][dD]|[dD][aA][rR][kK][gG][rR][aA][yY]|[dD][aA][rR][kK][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][gG][rR][eE][yY]|[dD][aA][rR][kK][kK][hH][aA][kK][iI]|[dD][aA][rR][kK][mM][aA][gG][eE][nN][tT][aA]|[dD][aA][rR][kK][oO][lL][iI][vV][eE][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][oO][rR][aA][nN][gG][eE]|[dD][aA][rR][kK][oO][rR][cC][hH][iI][dD]|[dD][aA][rR][kK][rR][eE][dD]|[dD][aA][rR][kK][sS][aA][lL][mM][oO][nN]|[dD][aA][rR][kK][sS][eE][aA][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][bB][lL][uU][eE]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][gG][rR][aA][yY]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][gG][rR][eE][yY]|[dD][aA][rR][kK][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[dD][aA][rR][kK][vV][iI][oO][lL][eE][tT]|[dD][eE][eE][pP][pP][iI][nN][kK]|[dD][eE][eE][pP][sS][kK][yY][bB][lL][uU][eE]|[dD][iI][mM][gG][rR][aA][yY]|[dD][iI][mM][gG][rR][eE][yY]|[dD][oO][dD][gG][eE][rR][bB][lL][uU][eE]|[fF][iI][eE][lL][dD]|[fF][iI][eE][lL][dD][tT][eE][xX][tT]|[fF][iI][rR][eE][bB][rR][iI][cC][kK]|[fF][lL][oO][rR][aA][lL][wW][hH][iI][tT][eE]|[fF][oO][rR][eE][sS][tT][gG][rR][eE][eE][nN]|[fF][uU][cC][hH][sS][iI][aA]|[gG][aA][iI][nN][sS][bB][oO][rR][oO]|[gG][hH][oO][sS][tT][wW][hH][iI][tT][eE]|[gG][oO][lL][dD]|[gG][oO][lL][dD][eE][nN][rR][oO][dD]|[gG][rR][aA][yY]|[gG][rR][aA][yY][tT][eE][xX][tT]|[gG][rR][eE][eE][nN]|[gG][rR][eE][eE][nN][yY][eE][lL][lL][oO][wW]|[gG][rR][eE][yY]|[hH][iI][gG][hH][lL][iI][gG][hH][tT]|[hH][iI][gG][hH][lL][iI][gG][hH][tT][tT][eE][xX][tT]|[hH][oO][nN][eE][yY][dD][eE][wW]|[hH][oO][tT][pP][iI][nN][kK]|[iI][nN][aA][cC][tT][iI][vV][eE][bB][oO][rR][dD][eE][rR]|[iI][nN][aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN]|[iI][nN][aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN][tT][eE][xX][tT]|[iI][nN][dD][iI][aA][nN][rR][eE][dD]|[iI][nN][dD][iI][gG][oO]|[iI][nN][fF][oO][bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]|[iI][nN][fF][oO][tT][eE][xX][tT]|[iI][vV][oO][rR][yY]|[kK][hH][aA][kK][iI]|[lL][aA][vV][eE][nN][dD][eE][rR]|[lL][aA][vV][eE][nN][dD][eE][rR][bB][lL][uU][sS][hH]|[lL][aA][wW][nN][gG][rR][eE][eE][nN]|[lL][eE][mM][oO][nN][cC][hH][iI][fF][fF][oO][nN]|[lL][iI][gG][hH][tT][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][cC][oO][rR][aA][lL]|[lL][iI][gG][hH][tT][cC][yY][aA][nN]|[lL][iI][gG][hH][tT][gG][oO][lL][dD][eE][nN][rR][oO][dD][yY][eE][lL][lL][oO][wW]|[lL][iI][gG][hH][tT][gG][rR][aA][yY]|[lL][iI][gG][hH][tT][gG][rR][eE][eE][nN]|[lL][iI][gG][hH][tT][gG][rR][eE][yY]|[lL][iI][gG][hH][tT][pP][iI][nN][kK]|[lL][iI][gG][hH][tT][sS][aA][lL][mM][oO][nN]|[lL][iI][gG][hH][tT][sS][eE][aA][gG][rR][eE][eE][nN]|[lL][iI][gG][hH][tT][sS][kK][yY][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][sS][lL][aA][tT][eE][gG][rR][aA][yY]|[lL][iI][gG][hH][tT][sS][lL][aA][tT][eE][gG][rR][eE][yY]|[lL][iI][gG][hH][tT][sS][tT][eE][eE][lL][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][yY][eE][lL][lL][oO][wW]|[lL][iI][mM][eE]|[lL][iI][mM][eE][gG][rR][eE][eE][nN]|[lL][iI][nN][eE][nN]|[lL][iI][nN][kK][tT][eE][xX][tT]|[mM][aA][gG][eE][nN][tT][aA]|[mM][aA][rR][kK]|[mM][aA][rR][kK][tT][eE][xX][tT]|[mM][aA][rR][oO][oO][nN]|[mM][eE][dD][iI][uU][mM][aA][qQ][uU][aA][mM][aA][rR][iI][nN][eE]|[mM][eE][dD][iI][uU][mM][bB][lL][uU][eE]|[mM][eE][dD][iI][uU][mM][oO][rR][cC][hH][iI][dD]|[mM][eE][dD][iI][uU][mM][pP][uU][rR][pP][lL][eE]|[mM][eE][dD][iI][uU][mM][sS][eE][aA][gG][rR][eE][eE][nN]|[mM][eE][dD][iI][uU][mM][sS][lL][aA][tT][eE][bB][lL][uU][eE]|[mM][eE][dD][iI][uU][mM][sS][pP][rR][iI][nN][gG][gG][rR][eE][eE][nN]|[mM][eE][dD][iI][uU][mM][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[mM][eE][dD][iI][uU][mM][vV][iI][oO][lL][eE][tT][rR][eE][dD]|[mM][eE][nN][uU]|[mM][eE][nN][uU][tT][eE][xX][tT]|[mM][iI][dD][nN][iI][gG][hH][tT][bB][lL][uU][eE]|[mM][iI][nN][tT][cC][rR][eE][aA][mM]|[mM][iI][sS][tT][yY][rR][oO][sS][eE]|[mM][oO][cC][cC][aA][sS][iI][nN]|[nN][aA][vV][aA][jJ][oO][wW][hH][iI][tT][eE]|[nN][aA][vV][yY]|[nN][oO][nN][eE]|[oO][lL][dD][lL][aA][cC][eE]|[oO][lL][iI][vV][eE]|[oO][lL][iI][vV][eE][dD][rR][aA][bB]|[oO][rR][aA][nN][gG][eE]|[oO][rR][aA][nN][gG][eE][rR][eE][dD]|[oO][rR][cC][hH][iI][dD]|[pP][aA][lL][eE][gG][oO][lL][dD][eE][nN][rR][oO][dD]|[pP][aA][lL][eE][gG][rR][eE][eE][nN]|[pP][aA][lL][eE][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[pP][aA][lL][eE][vV][iI][oO][lL][eE][tT][rR][eE][dD]|[pP][aA][pP][aA][yY][aA][wW][hH][iI][pP]|[pP][eE][aA][cC][hH][pP][uU][fF][fF]|[pP][eE][rR][uU]|[pP][iI][nN][kK]|[pP][lL][uU][mM]|[pP][oO][wW][dD][eE][rR][bB][lL][uU][eE]|[pP][uU][rR][pP][lL][eE]|[rR][eE][bB][eE][cC][cC][aA][pP][uU][rR][pP][lL][eE]|[rR][eE][dD]|[rR][oO][sS][yY][bB][rR][oO][wW][nN]|[rR][oO][yY][aA][lL][bB][lL][uU][eE]|[sS][aA][dD][dD][lL][eE][bB][rR][oO][wW][nN]|[sS][aA][lL][mM][oO][nN]|[sS][aA][nN][dD][yY][bB][rR][oO][wW][nN]|[sS][cC][rR][oO][lL][lL][bB][aA][rR]|[sS][eE][aA][gG][rR][eE][eE][nN]|[sS][eE][aA][sS][hH][eE][lL][lL]|[sS][eE][lL][eE][cC][tT][eE][dD][iI][tT][eE][mM]|[sS][eE][lL][eE][cC][tT][eE][dD][iI][tT][eE][mM][tT][eE][xX][tT]|[sS][iI][eE][nN][nN][aA]|[sS][iI][lL][vV][eE][rR]|[sS][kK][yY][bB][lL][uU][eE]|[sS][lL][aA][tT][eE][bB][lL][uU][eE]|[sS][lL][aA][tT][eE][gG][rR][aA][yY]|[sS][lL][aA][tT][eE][gG][rR][eE][yY]|[sS][nN][oO][wW]|[sS][pP][rR][iI][nN][gG][gG][rR][eE][eE][nN]|[sS][rR][gG][bB]|[sS][tT][eE][eE][lL][bB][lL][uU][eE]|[tT][aA][nN]|[tT][eE][aA][lL]|[tT][hH][iI][sS][tT][lL][eE]|[tT][hH][rR][eE][eE][dD][dD][aA][rR][kK][sS][hH][aA][dD][oO][wW]|[tT][hH][rR][eE][eE][dD][fF][aA][cC][eE]|[tT][hH][rR][eE][eE][dD][hH][iI][gG][hH][lL][iI][gG][hH][tT]|[tT][hH][rR][eE][eE][dD][lL][iI][gG][hH][tT][sS][hH][aA][dD][oO][wW]|[tT][hH][rR][eE][eE][dD][sS][hH][aA][dD][oO][wW]|[tT][oO][mM][aA][tT][oO]|[tT][rR][aA][nN][sS][pP][aA][rR][eE][nN][tT]|[tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[vV][iI][oO][lL][eE][tT]|[vV][iI][sS][iI][tT][eE][dD][tT][eE][xX][tT]|[wW][hH][eE][aA][tT]|[wW][hH][iI][tT][eE]|[wW][hH][iI][tT][eE][sS][mM][oO][kK][eE]|[wW][iI][nN][dD][oO][wW]|[wW][iI][nN][dD][oO][wW][fF][rR][aA][mM][eE]|[wW][iI][nN][dD][oO][wW][tT][eE][xX][tT]|[xX][yY][zZ]|[yY][eE][lL][lL][oO][wW]|[yY][eE][lL][lL][oO][wW][gG][rR][eE][eE][nN])))(?:\s+(?:(?:[Nn][Oo][Nn][Ee]|[Uu][Nn][Dd][Ee][Rr][Ll][Ii][Nn][Ee]|[Oo][Vv][Ee][Rr][Ll][Ii][Nn][Ee]|[Ll][Ii][Nn][Ee]-[Tt][Hh][Rr][Oo][Uu][Gg][Hh]|[Bb][Ll][Ii][Nn][Kk]|[Ss][Pp][Ee][Ll][Ll][Ii][Nn][Gg]-[Ee][Rr][Rr][Oo][Rr]|[Gg][Rr][Aa][Mm][Mm][Aa][Rr]-[Ee][Rr][Rr][Oo][Rr])|(?:[Ss][Oo][Ll][Ii][Dd]|[Dd][Oo][Uu][Bb][Ll][Ee]|[Dd][Oo][Tt][Tt][Ee][Dd]|[Dd][Aa][Ss][Hh][Ee][Dd]|[Ww][Aa][Vv][Yy])|(?:[Tt][Hh][Ii][Nn]|[Mm][Ee][Dd][Ii][Uu][Mm]|[Tt][Hh][Ii][Cc][Kk]|[Aa][Uu][Tt][Oo]|[Ff][Rr][Oo][Mm]-[Ff][Oo][Nn][Tt])|(?:[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*))|(?:[-+]?0+(?:\.0+)?)|(?:#(?:[0-9A-Fa-f]{3}|[0-9A-Fa-f]{4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8}))|(?:[A-Za-z][A-Za-z0-9-]*\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))|(?:[aA][cC][cC][eE][nN][tT][cC][oO][lL][oO][rR]|[aA][cC][cC][eE][nN][tT][cC][oO][lL][oO][rR][tT][eE][xX][tT]|[aA][cC][tT][iI][vV][eE][bB][oO][rR][dD][eE][rR]|[aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN]|[aA][cC][tT][iI][vV][eE][tT][eE][xX][tT]|[aA][lL][iI][cC][eE][bB][lL][uU][eE]|[aA][nN][tT][iI][qQ][uU][eE][wW][hH][iI][tT][eE]|[aA][pP][pP][wW][oO][rR][kK][sS][pP][aA][cC][eE]|[aA][qQ][uU][aA]|[aA][qQ][uU][aA][mM][aA][rR][iI][nN][eE]|[aA][zZ][uU][rR][eE]|[bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]|[bB][eE][iI][gG][eE]|[bB][iI][sS][qQ][uU][eE]|[bB][lL][aA][cC][kK]|[bB][lL][aA][nN][cC][hH][eE][dD][aA][lL][mM][oO][nN][dD]|[bB][lL][uU][eE]|[bB][lL][uU][eE][vV][iI][oO][lL][eE][tT]|[bB][rR][oO][wW][nN]|[bB][uU][rR][lL][yY][wW][oO][oO][dD]|[bB][uU][tT][tT][oO][nN][bB][oO][rR][dD][eE][rR]|[bB][uU][tT][tT][oO][nN][fF][aA][cC][eE]|[bB][uU][tT][tT][oO][nN][hH][iI][gG][hH][lL][iI][gG][hH][tT]|[bB][uU][tT][tT][oO][nN][sS][hH][aA][dD][oO][wW]|[bB][uU][tT][tT][oO][nN][tT][eE][xX][tT]|[cC][aA][dD][eE][tT][bB][lL][uU][eE]|[cC][aA][nN][vV][aA][sS]|[cC][aA][nN][vV][aA][sS][tT][eE][xX][tT]|[cC][aA][pP][tT][iI][oO][nN][tT][eE][xX][tT]|[cC][hH][aA][rR][tT][rR][eE][uU][sS][eE]|[cC][hH][oO][cC][oO][lL][aA][tT][eE]|[cC][oO][rR][aA][lL]|[cC][oO][rR][nN][fF][lL][oO][wW][eE][rR][bB][lL][uU][eE]|[cC][oO][rR][nN][sS][iI][lL][kK]|[cC][rR][iI][mM][sS][oO][nN]|[cC][uU][rR][rR][eE][nN][tT][cC][oO][lL][oO][rR]|[cC][yY][aA][nN]|[dD][aA][rR][kK][bB][lL][uU][eE]|[dD][aA][rR][kK][cC][yY][aA][nN]|[dD][aA][rR][kK][gG][oO][lL][dD][eE][nN][rR][oO][dD]|[dD][aA][rR][kK][gG][rR][aA][yY]|[dD][aA][rR][kK][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][gG][rR][eE][yY]|[dD][aA][rR][kK][kK][hH][aA][kK][iI]|[dD][aA][rR][kK][mM][aA][gG][eE][nN][tT][aA]|[dD][aA][rR][kK][oO][lL][iI][vV][eE][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][oO][rR][aA][nN][gG][eE]|[dD][aA][rR][kK][oO][rR][cC][hH][iI][dD]|[dD][aA][rR][kK][rR][eE][dD]|[dD][aA][rR][kK][sS][aA][lL][mM][oO][nN]|[dD][aA][rR][kK][sS][eE][aA][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][bB][lL][uU][eE]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][gG][rR][aA][yY]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][gG][rR][eE][yY]|[dD][aA][rR][kK][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[dD][aA][rR][kK][vV][iI][oO][lL][eE][tT]|[dD][eE][eE][pP][pP][iI][nN][kK]|[dD][eE][eE][pP][sS][kK][yY][bB][lL][uU][eE]|[dD][iI][mM][gG][rR][aA][yY]|[dD][iI][mM][gG][rR][eE][yY]|[dD][oO][dD][gG][eE][rR][bB][lL][uU][eE]|[fF][iI][eE][lL][dD]|[fF][iI][eE][lL][dD][tT][eE][xX][tT]|[fF][iI][rR][eE][bB][rR][iI][cC][kK]|[fF][lL][oO][rR][aA][lL][wW][hH][iI][tT][eE]|[fF][oO][rR][eE][sS][tT][gG][rR][eE][eE][nN]|[fF][uU][cC][hH][sS][iI][aA]|[gG][aA][iI][nN][sS][bB][oO][rR][oO]|[gG][hH][oO][sS][tT][wW][hH][iI][tT][eE]|[gG][oO][lL][dD]|[gG][oO][lL][dD][eE][nN][rR][oO][dD]|[gG][rR][aA][yY]|[gG][rR][aA][yY][tT][eE][xX][tT]|[gG][rR][eE][eE][nN]|[gG][rR][eE][eE][nN][yY][eE][lL][lL][oO][wW]|[gG][rR][eE][yY]|[hH][iI][gG][hH][lL][iI][gG][hH][tT]|[hH][iI][gG][hH][lL][iI][gG][hH][tT][tT][eE][xX][tT]|[hH][oO][nN][eE][yY][dD][eE][wW]|[hH][oO][tT][pP][iI][nN][kK]|[iI][nN][aA][cC][tT][iI][vV][eE][bB][oO][rR][dD][eE][rR]|[iI][nN][aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN]|[iI][nN][aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN][tT][eE][xX][tT]|[iI][nN][dD][iI][aA][nN][rR][eE][dD]|[iI][nN][dD][iI][gG][oO]|[iI][nN][fF][oO][bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]|[iI][nN][fF][oO][tT][eE][xX][tT]|[iI][vV][oO][rR][yY]|[kK][hH][aA][kK][iI]|[lL][aA][vV][eE][nN][dD][eE][rR]|[lL][aA][vV][eE][nN][dD][eE][rR][bB][lL][uU][sS][hH]|[lL][aA][wW][nN][gG][rR][eE][eE][nN]|[lL][eE][mM][oO][nN][cC][hH][iI][fF][fF][oO][nN]|[lL][iI][gG][hH][tT][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][cC][oO][rR][aA][lL]|[lL][iI][gG][hH][tT][cC][yY][aA][nN]|[lL][iI][gG][hH][tT][gG][oO][lL][dD][eE][nN][rR][oO][dD][yY][eE][lL][lL][oO][wW]|[lL][iI][gG][hH][tT][gG][rR][aA][yY]|[lL][iI][gG][hH][tT][gG][rR][eE][eE][nN]|[lL][iI][gG][hH][tT][gG][rR][eE][yY]|[lL][iI][gG][hH][tT][pP][iI][nN][kK]|[lL][iI][gG][hH][tT][sS][aA][lL][mM][oO][nN]|[lL][iI][gG][hH][tT][sS][eE][aA][gG][rR][eE][eE][nN]|[lL][iI][gG][hH][tT][sS][kK][yY][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][sS][lL][aA][tT][eE][gG][rR][aA][yY]|[lL][iI][gG][hH][tT][sS][lL][aA][tT][eE][gG][rR][eE][yY]|[lL][iI][gG][hH][tT][sS][tT][eE][eE][lL][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][yY][eE][lL][lL][oO][wW]|[lL][iI][mM][eE]|[lL][iI][mM][eE][gG][rR][eE][eE][nN]|[lL][iI][nN][eE][nN]|[lL][iI][nN][kK][tT][eE][xX][tT]|[mM][aA][gG][eE][nN][tT][aA]|[mM][aA][rR][kK]|[mM][aA][rR][kK][tT][eE][xX][tT]|[mM][aA][rR][oO][oO][nN]|[mM][eE][dD][iI][uU][mM][aA][qQ][uU][aA][mM][aA][rR][iI][nN][eE]|[mM][eE][dD][iI][uU][mM][bB][lL][uU][eE]|[mM][eE][dD][iI][uU][mM][oO][rR][cC][hH][iI][dD]|[mM][eE][dD][iI][uU][mM][pP][uU][rR][pP][lL][eE]|[mM][eE][dD][iI][uU][mM][sS][eE][aA][gG][rR][eE][eE][nN]|[mM][eE][dD][iI][uU][mM][sS][lL][aA][tT][eE][bB][lL][uU][eE]|[mM][eE][dD][iI][uU][mM][sS][pP][rR][iI][nN][gG][gG][rR][eE][eE][nN]|[mM][eE][dD][iI][uU][mM][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[mM][eE][dD][iI][uU][mM][vV][iI][oO][lL][eE][tT][rR][eE][dD]|[mM][eE][nN][uU]|[mM][eE][nN][uU][tT][eE][xX][tT]|[mM][iI][dD][nN][iI][gG][hH][tT][bB][lL][uU][eE]|[mM][iI][nN][tT][cC][rR][eE][aA][mM]|[mM][iI][sS][tT][yY][rR][oO][sS][eE]|[mM][oO][cC][cC][aA][sS][iI][nN]|[nN][aA][vV][aA][jJ][oO][wW][hH][iI][tT][eE]|[nN][aA][vV][yY]|[nN][oO][nN][eE]|[oO][lL][dD][lL][aA][cC][eE]|[oO][lL][iI][vV][eE]|[oO][lL][iI][vV][eE][dD][rR][aA][bB]|[oO][rR][aA][nN][gG][eE]|[oO][rR][aA][nN][gG][eE][rR][eE][dD]|[oO][rR][cC][hH][iI][dD]|[pP][aA][lL][eE][gG][oO][lL][dD][eE][nN][rR][oO][dD]|[pP][aA][lL][eE][gG][rR][eE][eE][nN]|[pP][aA][lL][eE][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[pP][aA][lL][eE][vV][iI][oO][lL][eE][tT][rR][eE][dD]|[pP][aA][pP][aA][yY][aA][wW][hH][iI][pP]|[pP][eE][aA][cC][hH][pP][uU][fF][fF]|[pP][eE][rR][uU]|[pP][iI][nN][kK]|[pP][lL][uU][mM]|[pP][oO][wW][dD][eE][rR][bB][lL][uU][eE]|[pP][uU][rR][pP][lL][eE]|[rR][eE][bB][eE][cC][cC][aA][pP][uU][rR][pP][lL][eE]|[rR][eE][dD]|[rR][oO][sS][yY][bB][rR][oO][wW][nN]|[rR][oO][yY][aA][lL][bB][lL][uU][eE]|[sS][aA][dD][dD][lL][eE][bB][rR][oO][wW][nN]|[sS][aA][lL][mM][oO][nN]|[sS][aA][nN][dD][yY][bB][rR][oO][wW][nN]|[sS][cC][rR][oO][lL][lL][bB][aA][rR]|[sS][eE][aA][gG][rR][eE][eE][nN]|[sS][eE][aA][sS][hH][eE][lL][lL]|[sS][eE][lL][eE][cC][tT][eE][dD][iI][tT][eE][mM]|[sS][eE][lL][eE][cC][tT][eE][dD][iI][tT][eE][mM][tT][eE][xX][tT]|[sS][iI][eE][nN][nN][aA]|[sS][iI][lL][vV][eE][rR]|[sS][kK][yY][bB][lL][uU][eE]|[sS][lL][aA][tT][eE][bB][lL][uU][eE]|[sS][lL][aA][tT][eE][gG][rR][aA][yY]|[sS][lL][aA][tT][eE][gG][rR][eE][yY]|[sS][nN][oO][wW]|[sS][pP][rR][iI][nN][gG][gG][rR][eE][eE][nN]|[sS][rR][gG][bB]|[sS][tT][eE][eE][lL][bB][lL][uU][eE]|[tT][aA][nN]|[tT][eE][aA][lL]|[tT][hH][iI][sS][tT][lL][eE]|[tT][hH][rR][eE][eE][dD][dD][aA][rR][kK][sS][hH][aA][dD][oO][wW]|[tT][hH][rR][eE][eE][dD][fF][aA][cC][eE]|[tT][hH][rR][eE][eE][dD][hH][iI][gG][hH][lL][iI][gG][hH][tT]|[tT][hH][rR][eE][eE][dD][lL][iI][gG][hH][tT][sS][hH][aA][dD][oO][wW]|[tT][hH][rR][eE][eE][dD][sS][hH][aA][dD][oO][wW]|[tT][oO][mM][aA][tT][oO]|[tT][rR][aA][nN][sS][pP][aA][rR][eE][nN][tT]|[tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[vV][iI][oO][lL][eE][tT]|[vV][iI][sS][iI][tT][eE][dD][tT][eE][xX][tT]|[wW][hH][eE][aA][tT]|[wW][hH][iI][tT][eE]|[wW][hH][iI][tT][eE][sS][mM][oO][kK][eE]|[wW][iI][nN][dD][oO][wW]|[wW][iI][nN][dD][oO][wW][fF][rR][aA][mM][eE]|[wW][iI][nN][dD][oO][wW][tT][eE][xX][tT]|[xX][yY][zZ]|[yY][eE][lL][lL][oO][wW]|[yY][eE][lL][lL][oO][wW][gG][rR][eE][eE][nN])))*)$
        /**
         * Typography §text-transform: values MUST be composed of recognised keywords (for example none, uppercase, full-width, full-size-kana, or math-* variants), CSS global keywords, or custom property references via var().
         * Text transform list
         * Whitespace-separated sequence of text-transform keywords per Typography §text-transform and CSS Text Module Levels 3-4.
         */
        export type TextTransformList = string; // ^(?:(?:[Ii][Nn][Hh][Ee][Rr][Ii][Tt]|[Ii][Nn][Ii][Tt][Ii][Aa][Ll]|[Uu][Nn][Ss][Ee][Tt]|[Rr][Ee][Vv][Ee][Rr][Tt](?:-[Ll][Aa][Yy][Ee][Rr])?)|(?:[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)|(?:(?:[Nn][Oo][Nn][Ee]|[Cc][Aa][Pp][Ii][Tt][Aa][Ll][Ii][Zz][Ee]|[Uu][Pp][Pp][Ee][Rr][Cc][Aa][Ss][Ee]|[Ll][Oo][Ww][Ee][Rr][Cc][Aa][Ss][Ee]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Ff][Uu][Ll][Ll]-[Ss][Ii][Zz][Ee]-[Kk][Aa][Nn][Aa]|[Mm][Aa][Tt][Hh]-[Aa][Uu][Tt][Oo]|[Mm][Aa][Tt][Hh](?:-[A-Za-z]+)+))(?:\s+(?:[Nn][Oo][Nn][Ee]|[Cc][Aa][Pp][Ii][Tt][Aa][Ll][Ii][Zz][Ee]|[Uu][Pp][Pp][Ee][Rr][Cc][Aa][Ss][Ee]|[Ll][Oo][Ww][Ee][Rr][Cc][Aa][Ss][Ee]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Ff][Uu][Ll][Ll]-[Ss][Ii][Zz][Ee]-[Kk][Aa][Nn][Aa]|[Mm][Aa][Tt][Hh]-[Aa][Uu][Tt][Oo]|[Mm][Aa][Tt][Hh](?:-[A-Za-z]+)+))*)$
        /**
         * Terminology §token and Format and serialisation §$ref.
         * Design token
         * Object declaring either $value or $ref along with optional metadata per Terminology §token and Format and serialisation §$ref.
         */
        export type Token = MetadataMembers & TokenCore;
        export type TokenCore = (({
            "$value": unknown;
        } & Record<string, unknown>) | ({
            "$ref": string;
        } & Record<string, unknown>)) & ({
            "$type"?: TypeIdentifier;
            "$value"?: Record<string, unknown>;
            "$ref"?: string;
            "$description"?: MetadataMembers["$description"];
            "$extensions"?: MetadataMembers["$extensions"];
            "$deprecated"?: MetadataMembers["$deprecated"];
            "$lastModified"?: MetadataMembers["$lastModified"];
            "$lastUsed"?: MetadataMembers["$lastUsed"];
            "$usageCount"?: MetadataMembers["$usageCount"];
            "$author"?: MetadataMembers["$author"];
            "$tags"?: MetadataMembers["$tags"];
            "$hash"?: MetadataMembers["$hash"];
        } & Record<string, unknown>);
        /**
         * Architecture and model §tokens-and-collections: document members other than $-prefixed metadata are tokens or nested collections.
         * Token member map
         * Tree of design token or collection entries keyed by names that do not begin with $.
         */
        export interface TokenMembers {
            [pattern: string]: Node; /* Patterns: ^(?!\$) */
        }
        /**
         * Metadata table: strings such as $author MUST be trimmed.
         * Trimmed string
         * Non-empty string without leading or trailing whitespace per Metadata §metadata.
         */
        export type TrimmedString = string; // ^(?!\s)(?:.*\S)?$
        /**
         * Format and serialisation §$type: registry types include border, color, component, cursor, dimension, duration, easing, elevation, filter, font, fontFace, gradient, line-height, motion, opacity, shadow, strokeStyle, typography, and z-index. Vendors MAY mint additional identifiers and SHOULD namespace them (Extensibility §extensibility) but the schema accepts any dot-separated ASCII identifier without whitespace.
         * Token type identifier
         * Registered DTIF $type or vendor-defined identifier per Format and serialisation §$type.
         * example:
         * color
         * typography
         * com.example.tokens.radius
         */
        export type TypeIdentifier = string; // ^(?:[A-Za-z][A-Za-z0-9_-]*)(?:\.[A-Za-z0-9_-]+)*$
        export interface Typography {
            [name: string]: any;
            /**
             * Canonical values such as 'body', 'heading', and 'caption' are registered. Custom values matching this pattern MAY be used; consumers MUST ignore unrecognised types to preserve compatibility.
             */
            typographyType?: string; // ^[a-zA-Z][\w-]*$
            /**
             * Typography §typography: fontFamily strings MUST follow CSS <family-name> grammar or reference an existing font token.
             * Typography font family
             * Family name string or reference providing the typography font family.
             */
            fontFamily: 
            /**
             * Typography §typography: fontFamily strings MUST follow CSS <family-name> grammar or reference an existing font token.
             * Typography font family
             * Family name string or reference providing the typography font family.
             */
            /**
             * Typography §typography: fontFamily strings MUST follow CSS <family-name> grammar or reference an existing font token.
             * Typography font family
             * Family name string or reference providing the typography font family.
             */ (string /* ^(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+')$ */ | string /* ^-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*(?:[ \t]+-{0,2}(?:[A-Za-z_]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])(?:[A-Za-z0-9_-]|[^\x00-\x7F]|\\[0-9A-Fa-f]{1,6}(?:\r\n|[ \t\n\r\f])?|\\[^\r\n\f0-9A-Fa-f])*)*$ */) | /**
             * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
             * Pointer alias
             * Object aliasing another token via $ref per Token types §value.
             */ Reference;
            fontSize: FontDimensionReference;
            /**
             * Typography §line-height: value MUST be a non-negative ratio or font-dimension measurement.
             * Line height value
             * Baseline-to-baseline distance as a ratio or font-dimension.
             */
            lineHeight?: /**
             * Typography §line-height: value MUST be a non-negative ratio or font-dimension measurement.
             * Line height value
             * Baseline-to-baseline distance as a ratio or font-dimension.
             */ number | /**
             * Typography §line-height: value MUST be a non-negative ratio or font-dimension measurement.
             * Line height value
             * Baseline-to-baseline distance as a ratio or font-dimension.
             */ ({
                dimensionType: "length";
                value: number;
                /**
                 * MUST conform to CSS <length> or <percentage> (css-values-4) or native point/density-independent units (IOS-POINTS, ANDROID-DP-SP).
                 */
                unit: string; // ^(?:%|[A-Za-z][A-Za-z0-9-]*)$
                /**
                 * When true, MUST follow Dynamic Type (IOS-DYNAMIC-TYPE) and Android scale-independent behaviour (ANDROID-DP-SP).
                 * Whether the value scales with the user's font settings.
                 */
                fontScale?: boolean;
            } | /**
             * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
             * Pointer alias
             * Object aliasing another token via $ref per Token types §value.
             */ Reference);
            /**
             * MUST follow CSS letter-spacing grammar and reuse font-dimension unit conversions.
             */
            letterSpacing?: /* MUST follow CSS letter-spacing grammar and reuse font-dimension unit conversions. */ /**
             * Typography §font-dimensions and §font-face: values MAY embed inline font measurements or alias another token with the same $type.
             * Font dimension literal or alias
             * Font-specific length measurement or $ref alias per Typography §font-dimensions and Format and serialisation §$ref.
             */ FontDimensionReference | ("normal");
            /**
             * MUST conform to CSS word-spacing <length-percentage> grammar and platform unit semantics.
             */
            wordSpacing?: /* MUST conform to CSS word-spacing <length-percentage> grammar and platform unit semantics. */ /**
             * Typography §font-dimensions and §font-face: values MAY embed inline font measurements or alias another token with the same $type.
             * Font dimension literal or alias
             * Font-specific length measurement or $ref alias per Typography §font-dimensions and Format and serialisation §$ref.
             */ FontDimensionReference | ("normal");
            /**
             * MUST match CSS font-weight absolute or relative productions and map to platform weight APIs.
             */
            fontWeight?: /* MUST match CSS font-weight absolute or relative productions and map to platform weight APIs. */ number | /* String weights MUST conform to CSS <font-weight-absolute>, <font-weight-relative>, or <font-weight-range> productions (css-fonts-4). */ FontWeightString /* ^(?:[Bb][Oo][Ll][Dd][Ee][Rr]|[Ll][Ii][Gg][Hh][Tt][Ee][Rr]|(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?))(?:\s+(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Bb][Oo][Ll][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?)))?)$ */;
            /**
             * MUST conform to CSS font-style grammar and map to native italic traits or the slnt variation axis (css-fonts-4, IOS-FONT-TRAITS, IOS-FONT-VARIATIONS, ANDROID-FONT-SLANT, ANDROID-FONT-VARIATION).
             */
            fontStyle?: FontStyleString /* ^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Ii][Tt][Aa][Ll][Ii][Cc]|[Oo][Bb][Ll][Ii][Qq][Uu][Ee](?:\s+[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:[Dd][Ee][Gg]|[Gg][Rr][Aa][Dd]|[Rr][Aa][Dd]|[Tt][Uu][Rr][Nn]))?)$ */;
            /**
             * MUST match the CSS font-variant grammar when present.
             */
            fontVariant?: FontVariantString /* ^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|[Nn][Oo][Nn][Ee]|(?:(?:[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Nn][Oo]-[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Uu][Nn][Ii][Cc][Aa][Ss][Ee]|[Tt][Ii][Tt][Ll][Ii][Nn][Gg]-[Cc][Aa][Pp][Ss]|[Ll][Ii][Nn][Ii][Nn][Gg]-[Nn][Uu][Mm][Ss]|[Oo][Ll][Dd][Ss][Tt][Yy][Ll][Ee]-[Nn][Uu][Mm][Ss]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Nn][Uu][Mm][Ss]|[Tt][Aa][Bb][Uu][Ll][Aa][Rr]-[Nn][Uu][Mm][Ss]|[Dd][Ii][Aa][Gg][Oo][Nn][Aa][Ll]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Ss][Tt][Aa][Cc][Kk][Ee][Dd]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Oo][Rr][Dd][Ii][Nn][Aa][Ll]|[Ss][Ll][Aa][Ss][Hh][Ee][Dd]-[Zz][Ee][Rr][Oo]|[Jj][Ii][Ss]78|[Jj][Ii][Ss]83|[Jj][Ii][Ss]90|[Jj][Ii][Ss]04|[Ss][Ii][Mm][Pp][Ll][Ii][Ff][Ii][Ee][Dd]|[Tt][Rr][Aa][Dd][Ii][Tt][Ii][Oo][Nn][Aa][Ll]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Rr][Uu][Bb][Yy]|[Ss][Uu][Bb]|[Ss][Uu][Pp][Ee][Rr]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ff][Oo][Rr][Mm][Ss]|[Ss][Tt][Yy][Ll][Ii][Ss][Tt][Ii][Cc]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Ss][Tt][Yy][Ll][Ee][Ss][Ee][Tt]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)|[Cc][Hh][Aa][Rr][Aa][Cc][Tt][Ee][Rr]-[Vv][Aa][Rr][Ii][Aa][Nn][Tt]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)|[Ss][Ww][Aa][Ss][Hh]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Oo][Rr][Nn][Aa][Mm][Ee][Nn][Tt][Ss]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Aa][Nn][Nn][Oo][Tt][Aa][Tt][Ii][Oo][Nn]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\))(?:\s+(?:[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Cc][Oo][Mm][Mm][Oo][Nn]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Dd][Ii][Ss][Cc][Rr][Ee][Tt][Ii][Oo][Nn][Aa][Rr][Yy]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Nn][Oo]-[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ll][Ii][Gg][Aa][Tt][Uu][Rr][Ee][Ss]|[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Nn][Oo]-[Cc][Oo][Nn][Tt][Ee][Xx][Tt][Uu][Aa][Ll]|[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Ss][Mm][Aa][Ll][Ll]-[Cc][Aa][Pp][Ss]|[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Aa][Ll][Ll]-[Pp][Ee][Tt][Ii][Tt][Ee]-[Cc][Aa][Pp][Ss]|[Uu][Nn][Ii][Cc][Aa][Ss][Ee]|[Tt][Ii][Tt][Ll][Ii][Nn][Gg]-[Cc][Aa][Pp][Ss]|[Ll][Ii][Nn][Ii][Nn][Gg]-[Nn][Uu][Mm][Ss]|[Oo][Ll][Dd][Ss][Tt][Yy][Ll][Ee]-[Nn][Uu][Mm][Ss]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Nn][Uu][Mm][Ss]|[Tt][Aa][Bb][Uu][Ll][Aa][Rr]-[Nn][Uu][Mm][Ss]|[Dd][Ii][Aa][Gg][Oo][Nn][Aa][Ll]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Ss][Tt][Aa][Cc][Kk][Ee][Dd]-[Ff][Rr][Aa][Cc][Tt][Ii][Oo][Nn][Ss]|[Oo][Rr][Dd][Ii][Nn][Aa][Ll]|[Ss][Ll][Aa][Ss][Hh][Ee][Dd]-[Zz][Ee][Rr][Oo]|[Jj][Ii][Ss]78|[Jj][Ii][Ss]83|[Jj][Ii][Ss]90|[Jj][Ii][Ss]04|[Ss][Ii][Mm][Pp][Ll][Ii][Ff][Ii][Ee][Dd]|[Tt][Rr][Aa][Dd][Ii][Tt][Ii][Oo][Nn][Aa][Ll]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Pp][Rr][Oo][Pp][Oo][Rr][Tt][Ii][Oo][Nn][Aa][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Rr][Uu][Bb][Yy]|[Ss][Uu][Bb]|[Ss][Uu][Pp][Ee][Rr]|[Hh][Ii][Ss][Tt][Oo][Rr][Ii][Cc][Aa][Ll]-[Ff][Oo][Rr][Mm][Ss]|[Ss][Tt][Yy][Ll][Ii][Ss][Tt][Ii][Cc]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Ss][Tt][Yy][Ll][Ee][Ss][Ee][Tt]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)|[Cc][Hh][Aa][Rr][Aa][Cc][Tt][Ee][Rr]-[Vv][Aa][Rr][Ii][Aa][Nn][Tt]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)|[Ss][Ww][Aa][Ss][Hh]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Oo][Rr][Nn][Aa][Mm][Ee][Nn][Tt][Ss]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*\s*\)|[Aa][Nn][Nn][Oo][Tt][Aa][Tt][Ii][Oo][Nn]\(\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*(?:\s*,\s*-{0,2}[A-Za-z_][A-Za-z0-9_-]*)*\s*\)))*))$ */;
            /**
             * MUST match the CSS font-stretch grammar when present.
             */
            fontStretch?: FontStretchString /* ^(?:[Nn][Oo][Rr][Mm][Aa][Ll]|(?:[Uu][Ll][Tt][Rr][Aa]|[Ee][Xx][Tt][Rr][Aa]|[Ss][Ee][Mm][Ii])-[Cc][Oo][Nn][Dd][Ee][Nn][Ss][Ee][Dd]|[Cc][Oo][Nn][Dd][Ee][Nn][Ss][Ee][Dd]|(?:[Ss][Ee][Mm][Ii]|[Ee][Xx][Tt][Rr][Aa]|[Uu][Ll][Tt][Rr][Aa])-[Ee][Xx][Pp][Aa][Nn][Dd][Ee][Dd]|[Ee][Xx][Pp][Aa][Nn][Dd][Ee][Dd]|\+?(?:0*(?:[1-9]\d{0,2})(?:\.\d+)?|0*1000(?:\.0+)?)%)$ */;
            /**
             * Typography §text-decoration: values MUST follow the CSS text-decoration shorthand grammar, including colour keywords and <length-percentage> thickness tokens.
             * Text decoration
             * CSS text-decoration shorthand including line, style, colour, and thickness components per Typography §text-decoration.
             */
            textDecoration?: string; // ^(?:(?:[Ii][Nn][Hh][Ee][Rr][Ii][Tt]|[Ii][Nn][Ii][Tt][Ii][Aa][Ll]|[Uu][Nn][Ss][Ee][Tt]|[Rr][Ee][Vv][Ee][Rr][Tt](?:-[Ll][Aa][Yy][Ee][Rr])?)|(?:(?:(?:[Nn][Oo][Nn][Ee]|[Uu][Nn][Dd][Ee][Rr][Ll][Ii][Nn][Ee]|[Oo][Vv][Ee][Rr][Ll][Ii][Nn][Ee]|[Ll][Ii][Nn][Ee]-[Tt][Hh][Rr][Oo][Uu][Gg][Hh]|[Bb][Ll][Ii][Nn][Kk]|[Ss][Pp][Ee][Ll][Ll][Ii][Nn][Gg]-[Ee][Rr][Rr][Oo][Rr]|[Gg][Rr][Aa][Mm][Mm][Aa][Rr]-[Ee][Rr][Rr][Oo][Rr])|(?:[Ss][Oo][Ll][Ii][Dd]|[Dd][Oo][Uu][Bb][Ll][Ee]|[Dd][Oo][Tt][Tt][Ee][Dd]|[Dd][Aa][Ss][Hh][Ee][Dd]|[Ww][Aa][Vv][Yy])|(?:[Tt][Hh][Ii][Nn]|[Mm][Ee][Dd][Ii][Uu][Mm]|[Tt][Hh][Ii][Cc][Kk]|[Aa][Uu][Tt][Oo]|[Ff][Rr][Oo][Mm]-[Ff][Oo][Nn][Tt])|(?:[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*))|(?:[-+]?0+(?:\.0+)?)|(?:#(?:[0-9A-Fa-f]{3}|[0-9A-Fa-f]{4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8}))|(?:[A-Za-z][A-Za-z0-9-]*\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))|(?:[aA][cC][cC][eE][nN][tT][cC][oO][lL][oO][rR]|[aA][cC][cC][eE][nN][tT][cC][oO][lL][oO][rR][tT][eE][xX][tT]|[aA][cC][tT][iI][vV][eE][bB][oO][rR][dD][eE][rR]|[aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN]|[aA][cC][tT][iI][vV][eE][tT][eE][xX][tT]|[aA][lL][iI][cC][eE][bB][lL][uU][eE]|[aA][nN][tT][iI][qQ][uU][eE][wW][hH][iI][tT][eE]|[aA][pP][pP][wW][oO][rR][kK][sS][pP][aA][cC][eE]|[aA][qQ][uU][aA]|[aA][qQ][uU][aA][mM][aA][rR][iI][nN][eE]|[aA][zZ][uU][rR][eE]|[bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]|[bB][eE][iI][gG][eE]|[bB][iI][sS][qQ][uU][eE]|[bB][lL][aA][cC][kK]|[bB][lL][aA][nN][cC][hH][eE][dD][aA][lL][mM][oO][nN][dD]|[bB][lL][uU][eE]|[bB][lL][uU][eE][vV][iI][oO][lL][eE][tT]|[bB][rR][oO][wW][nN]|[bB][uU][rR][lL][yY][wW][oO][oO][dD]|[bB][uU][tT][tT][oO][nN][bB][oO][rR][dD][eE][rR]|[bB][uU][tT][tT][oO][nN][fF][aA][cC][eE]|[bB][uU][tT][tT][oO][nN][hH][iI][gG][hH][lL][iI][gG][hH][tT]|[bB][uU][tT][tT][oO][nN][sS][hH][aA][dD][oO][wW]|[bB][uU][tT][tT][oO][nN][tT][eE][xX][tT]|[cC][aA][dD][eE][tT][bB][lL][uU][eE]|[cC][aA][nN][vV][aA][sS]|[cC][aA][nN][vV][aA][sS][tT][eE][xX][tT]|[cC][aA][pP][tT][iI][oO][nN][tT][eE][xX][tT]|[cC][hH][aA][rR][tT][rR][eE][uU][sS][eE]|[cC][hH][oO][cC][oO][lL][aA][tT][eE]|[cC][oO][rR][aA][lL]|[cC][oO][rR][nN][fF][lL][oO][wW][eE][rR][bB][lL][uU][eE]|[cC][oO][rR][nN][sS][iI][lL][kK]|[cC][rR][iI][mM][sS][oO][nN]|[cC][uU][rR][rR][eE][nN][tT][cC][oO][lL][oO][rR]|[cC][yY][aA][nN]|[dD][aA][rR][kK][bB][lL][uU][eE]|[dD][aA][rR][kK][cC][yY][aA][nN]|[dD][aA][rR][kK][gG][oO][lL][dD][eE][nN][rR][oO][dD]|[dD][aA][rR][kK][gG][rR][aA][yY]|[dD][aA][rR][kK][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][gG][rR][eE][yY]|[dD][aA][rR][kK][kK][hH][aA][kK][iI]|[dD][aA][rR][kK][mM][aA][gG][eE][nN][tT][aA]|[dD][aA][rR][kK][oO][lL][iI][vV][eE][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][oO][rR][aA][nN][gG][eE]|[dD][aA][rR][kK][oO][rR][cC][hH][iI][dD]|[dD][aA][rR][kK][rR][eE][dD]|[dD][aA][rR][kK][sS][aA][lL][mM][oO][nN]|[dD][aA][rR][kK][sS][eE][aA][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][bB][lL][uU][eE]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][gG][rR][aA][yY]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][gG][rR][eE][yY]|[dD][aA][rR][kK][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[dD][aA][rR][kK][vV][iI][oO][lL][eE][tT]|[dD][eE][eE][pP][pP][iI][nN][kK]|[dD][eE][eE][pP][sS][kK][yY][bB][lL][uU][eE]|[dD][iI][mM][gG][rR][aA][yY]|[dD][iI][mM][gG][rR][eE][yY]|[dD][oO][dD][gG][eE][rR][bB][lL][uU][eE]|[fF][iI][eE][lL][dD]|[fF][iI][eE][lL][dD][tT][eE][xX][tT]|[fF][iI][rR][eE][bB][rR][iI][cC][kK]|[fF][lL][oO][rR][aA][lL][wW][hH][iI][tT][eE]|[fF][oO][rR][eE][sS][tT][gG][rR][eE][eE][nN]|[fF][uU][cC][hH][sS][iI][aA]|[gG][aA][iI][nN][sS][bB][oO][rR][oO]|[gG][hH][oO][sS][tT][wW][hH][iI][tT][eE]|[gG][oO][lL][dD]|[gG][oO][lL][dD][eE][nN][rR][oO][dD]|[gG][rR][aA][yY]|[gG][rR][aA][yY][tT][eE][xX][tT]|[gG][rR][eE][eE][nN]|[gG][rR][eE][eE][nN][yY][eE][lL][lL][oO][wW]|[gG][rR][eE][yY]|[hH][iI][gG][hH][lL][iI][gG][hH][tT]|[hH][iI][gG][hH][lL][iI][gG][hH][tT][tT][eE][xX][tT]|[hH][oO][nN][eE][yY][dD][eE][wW]|[hH][oO][tT][pP][iI][nN][kK]|[iI][nN][aA][cC][tT][iI][vV][eE][bB][oO][rR][dD][eE][rR]|[iI][nN][aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN]|[iI][nN][aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN][tT][eE][xX][tT]|[iI][nN][dD][iI][aA][nN][rR][eE][dD]|[iI][nN][dD][iI][gG][oO]|[iI][nN][fF][oO][bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]|[iI][nN][fF][oO][tT][eE][xX][tT]|[iI][vV][oO][rR][yY]|[kK][hH][aA][kK][iI]|[lL][aA][vV][eE][nN][dD][eE][rR]|[lL][aA][vV][eE][nN][dD][eE][rR][bB][lL][uU][sS][hH]|[lL][aA][wW][nN][gG][rR][eE][eE][nN]|[lL][eE][mM][oO][nN][cC][hH][iI][fF][fF][oO][nN]|[lL][iI][gG][hH][tT][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][cC][oO][rR][aA][lL]|[lL][iI][gG][hH][tT][cC][yY][aA][nN]|[lL][iI][gG][hH][tT][gG][oO][lL][dD][eE][nN][rR][oO][dD][yY][eE][lL][lL][oO][wW]|[lL][iI][gG][hH][tT][gG][rR][aA][yY]|[lL][iI][gG][hH][tT][gG][rR][eE][eE][nN]|[lL][iI][gG][hH][tT][gG][rR][eE][yY]|[lL][iI][gG][hH][tT][pP][iI][nN][kK]|[lL][iI][gG][hH][tT][sS][aA][lL][mM][oO][nN]|[lL][iI][gG][hH][tT][sS][eE][aA][gG][rR][eE][eE][nN]|[lL][iI][gG][hH][tT][sS][kK][yY][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][sS][lL][aA][tT][eE][gG][rR][aA][yY]|[lL][iI][gG][hH][tT][sS][lL][aA][tT][eE][gG][rR][eE][yY]|[lL][iI][gG][hH][tT][sS][tT][eE][eE][lL][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][yY][eE][lL][lL][oO][wW]|[lL][iI][mM][eE]|[lL][iI][mM][eE][gG][rR][eE][eE][nN]|[lL][iI][nN][eE][nN]|[lL][iI][nN][kK][tT][eE][xX][tT]|[mM][aA][gG][eE][nN][tT][aA]|[mM][aA][rR][kK]|[mM][aA][rR][kK][tT][eE][xX][tT]|[mM][aA][rR][oO][oO][nN]|[mM][eE][dD][iI][uU][mM][aA][qQ][uU][aA][mM][aA][rR][iI][nN][eE]|[mM][eE][dD][iI][uU][mM][bB][lL][uU][eE]|[mM][eE][dD][iI][uU][mM][oO][rR][cC][hH][iI][dD]|[mM][eE][dD][iI][uU][mM][pP][uU][rR][pP][lL][eE]|[mM][eE][dD][iI][uU][mM][sS][eE][aA][gG][rR][eE][eE][nN]|[mM][eE][dD][iI][uU][mM][sS][lL][aA][tT][eE][bB][lL][uU][eE]|[mM][eE][dD][iI][uU][mM][sS][pP][rR][iI][nN][gG][gG][rR][eE][eE][nN]|[mM][eE][dD][iI][uU][mM][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[mM][eE][dD][iI][uU][mM][vV][iI][oO][lL][eE][tT][rR][eE][dD]|[mM][eE][nN][uU]|[mM][eE][nN][uU][tT][eE][xX][tT]|[mM][iI][dD][nN][iI][gG][hH][tT][bB][lL][uU][eE]|[mM][iI][nN][tT][cC][rR][eE][aA][mM]|[mM][iI][sS][tT][yY][rR][oO][sS][eE]|[mM][oO][cC][cC][aA][sS][iI][nN]|[nN][aA][vV][aA][jJ][oO][wW][hH][iI][tT][eE]|[nN][aA][vV][yY]|[nN][oO][nN][eE]|[oO][lL][dD][lL][aA][cC][eE]|[oO][lL][iI][vV][eE]|[oO][lL][iI][vV][eE][dD][rR][aA][bB]|[oO][rR][aA][nN][gG][eE]|[oO][rR][aA][nN][gG][eE][rR][eE][dD]|[oO][rR][cC][hH][iI][dD]|[pP][aA][lL][eE][gG][oO][lL][dD][eE][nN][rR][oO][dD]|[pP][aA][lL][eE][gG][rR][eE][eE][nN]|[pP][aA][lL][eE][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[pP][aA][lL][eE][vV][iI][oO][lL][eE][tT][rR][eE][dD]|[pP][aA][pP][aA][yY][aA][wW][hH][iI][pP]|[pP][eE][aA][cC][hH][pP][uU][fF][fF]|[pP][eE][rR][uU]|[pP][iI][nN][kK]|[pP][lL][uU][mM]|[pP][oO][wW][dD][eE][rR][bB][lL][uU][eE]|[pP][uU][rR][pP][lL][eE]|[rR][eE][bB][eE][cC][cC][aA][pP][uU][rR][pP][lL][eE]|[rR][eE][dD]|[rR][oO][sS][yY][bB][rR][oO][wW][nN]|[rR][oO][yY][aA][lL][bB][lL][uU][eE]|[sS][aA][dD][dD][lL][eE][bB][rR][oO][wW][nN]|[sS][aA][lL][mM][oO][nN]|[sS][aA][nN][dD][yY][bB][rR][oO][wW][nN]|[sS][cC][rR][oO][lL][lL][bB][aA][rR]|[sS][eE][aA][gG][rR][eE][eE][nN]|[sS][eE][aA][sS][hH][eE][lL][lL]|[sS][eE][lL][eE][cC][tT][eE][dD][iI][tT][eE][mM]|[sS][eE][lL][eE][cC][tT][eE][dD][iI][tT][eE][mM][tT][eE][xX][tT]|[sS][iI][eE][nN][nN][aA]|[sS][iI][lL][vV][eE][rR]|[sS][kK][yY][bB][lL][uU][eE]|[sS][lL][aA][tT][eE][bB][lL][uU][eE]|[sS][lL][aA][tT][eE][gG][rR][aA][yY]|[sS][lL][aA][tT][eE][gG][rR][eE][yY]|[sS][nN][oO][wW]|[sS][pP][rR][iI][nN][gG][gG][rR][eE][eE][nN]|[sS][rR][gG][bB]|[sS][tT][eE][eE][lL][bB][lL][uU][eE]|[tT][aA][nN]|[tT][eE][aA][lL]|[tT][hH][iI][sS][tT][lL][eE]|[tT][hH][rR][eE][eE][dD][dD][aA][rR][kK][sS][hH][aA][dD][oO][wW]|[tT][hH][rR][eE][eE][dD][fF][aA][cC][eE]|[tT][hH][rR][eE][eE][dD][hH][iI][gG][hH][lL][iI][gG][hH][tT]|[tT][hH][rR][eE][eE][dD][lL][iI][gG][hH][tT][sS][hH][aA][dD][oO][wW]|[tT][hH][rR][eE][eE][dD][sS][hH][aA][dD][oO][wW]|[tT][oO][mM][aA][tT][oO]|[tT][rR][aA][nN][sS][pP][aA][rR][eE][nN][tT]|[tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[vV][iI][oO][lL][eE][tT]|[vV][iI][sS][iI][tT][eE][dD][tT][eE][xX][tT]|[wW][hH][eE][aA][tT]|[wW][hH][iI][tT][eE]|[wW][hH][iI][tT][eE][sS][mM][oO][kK][eE]|[wW][iI][nN][dD][oO][wW]|[wW][iI][nN][dD][oO][wW][fF][rR][aA][mM][eE]|[wW][iI][nN][dD][oO][wW][tT][eE][xX][tT]|[xX][yY][zZ]|[yY][eE][lL][lL][oO][wW]|[yY][eE][lL][lL][oO][wW][gG][rR][eE][eE][nN])))(?:\s+(?:(?:[Nn][Oo][Nn][Ee]|[Uu][Nn][Dd][Ee][Rr][Ll][Ii][Nn][Ee]|[Oo][Vv][Ee][Rr][Ll][Ii][Nn][Ee]|[Ll][Ii][Nn][Ee]-[Tt][Hh][Rr][Oo][Uu][Gg][Hh]|[Bb][Ll][Ii][Nn][Kk]|[Ss][Pp][Ee][Ll][Ll][Ii][Nn][Gg]-[Ee][Rr][Rr][Oo][Rr]|[Gg][Rr][Aa][Mm][Mm][Aa][Rr]-[Ee][Rr][Rr][Oo][Rr])|(?:[Ss][Oo][Ll][Ii][Dd]|[Dd][Oo][Uu][Bb][Ll][Ee]|[Dd][Oo][Tt][Tt][Ee][Dd]|[Dd][Aa][Ss][Hh][Ee][Dd]|[Ww][Aa][Vv][Yy])|(?:[Tt][Hh][Ii][Nn]|[Mm][Ee][Dd][Ii][Uu][Mm]|[Tt][Hh][Ii][Cc][Kk]|[Aa][Uu][Tt][Oo]|[Ff][Rr][Oo][Mm]-[Ff][Oo][Nn][Tt])|(?:[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[Ee][+-]?\d+)?(?:%|[A-Za-z][A-Za-z0-9-]*))|(?:[-+]?0+(?:\.0+)?)|(?:#(?:[0-9A-Fa-f]{3}|[0-9A-Fa-f]{4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8}))|(?:[A-Za-z][A-Za-z0-9-]*\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))|(?:[aA][cC][cC][eE][nN][tT][cC][oO][lL][oO][rR]|[aA][cC][cC][eE][nN][tT][cC][oO][lL][oO][rR][tT][eE][xX][tT]|[aA][cC][tT][iI][vV][eE][bB][oO][rR][dD][eE][rR]|[aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN]|[aA][cC][tT][iI][vV][eE][tT][eE][xX][tT]|[aA][lL][iI][cC][eE][bB][lL][uU][eE]|[aA][nN][tT][iI][qQ][uU][eE][wW][hH][iI][tT][eE]|[aA][pP][pP][wW][oO][rR][kK][sS][pP][aA][cC][eE]|[aA][qQ][uU][aA]|[aA][qQ][uU][aA][mM][aA][rR][iI][nN][eE]|[aA][zZ][uU][rR][eE]|[bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]|[bB][eE][iI][gG][eE]|[bB][iI][sS][qQ][uU][eE]|[bB][lL][aA][cC][kK]|[bB][lL][aA][nN][cC][hH][eE][dD][aA][lL][mM][oO][nN][dD]|[bB][lL][uU][eE]|[bB][lL][uU][eE][vV][iI][oO][lL][eE][tT]|[bB][rR][oO][wW][nN]|[bB][uU][rR][lL][yY][wW][oO][oO][dD]|[bB][uU][tT][tT][oO][nN][bB][oO][rR][dD][eE][rR]|[bB][uU][tT][tT][oO][nN][fF][aA][cC][eE]|[bB][uU][tT][tT][oO][nN][hH][iI][gG][hH][lL][iI][gG][hH][tT]|[bB][uU][tT][tT][oO][nN][sS][hH][aA][dD][oO][wW]|[bB][uU][tT][tT][oO][nN][tT][eE][xX][tT]|[cC][aA][dD][eE][tT][bB][lL][uU][eE]|[cC][aA][nN][vV][aA][sS]|[cC][aA][nN][vV][aA][sS][tT][eE][xX][tT]|[cC][aA][pP][tT][iI][oO][nN][tT][eE][xX][tT]|[cC][hH][aA][rR][tT][rR][eE][uU][sS][eE]|[cC][hH][oO][cC][oO][lL][aA][tT][eE]|[cC][oO][rR][aA][lL]|[cC][oO][rR][nN][fF][lL][oO][wW][eE][rR][bB][lL][uU][eE]|[cC][oO][rR][nN][sS][iI][lL][kK]|[cC][rR][iI][mM][sS][oO][nN]|[cC][uU][rR][rR][eE][nN][tT][cC][oO][lL][oO][rR]|[cC][yY][aA][nN]|[dD][aA][rR][kK][bB][lL][uU][eE]|[dD][aA][rR][kK][cC][yY][aA][nN]|[dD][aA][rR][kK][gG][oO][lL][dD][eE][nN][rR][oO][dD]|[dD][aA][rR][kK][gG][rR][aA][yY]|[dD][aA][rR][kK][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][gG][rR][eE][yY]|[dD][aA][rR][kK][kK][hH][aA][kK][iI]|[dD][aA][rR][kK][mM][aA][gG][eE][nN][tT][aA]|[dD][aA][rR][kK][oO][lL][iI][vV][eE][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][oO][rR][aA][nN][gG][eE]|[dD][aA][rR][kK][oO][rR][cC][hH][iI][dD]|[dD][aA][rR][kK][rR][eE][dD]|[dD][aA][rR][kK][sS][aA][lL][mM][oO][nN]|[dD][aA][rR][kK][sS][eE][aA][gG][rR][eE][eE][nN]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][bB][lL][uU][eE]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][gG][rR][aA][yY]|[dD][aA][rR][kK][sS][lL][aA][tT][eE][gG][rR][eE][yY]|[dD][aA][rR][kK][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[dD][aA][rR][kK][vV][iI][oO][lL][eE][tT]|[dD][eE][eE][pP][pP][iI][nN][kK]|[dD][eE][eE][pP][sS][kK][yY][bB][lL][uU][eE]|[dD][iI][mM][gG][rR][aA][yY]|[dD][iI][mM][gG][rR][eE][yY]|[dD][oO][dD][gG][eE][rR][bB][lL][uU][eE]|[fF][iI][eE][lL][dD]|[fF][iI][eE][lL][dD][tT][eE][xX][tT]|[fF][iI][rR][eE][bB][rR][iI][cC][kK]|[fF][lL][oO][rR][aA][lL][wW][hH][iI][tT][eE]|[fF][oO][rR][eE][sS][tT][gG][rR][eE][eE][nN]|[fF][uU][cC][hH][sS][iI][aA]|[gG][aA][iI][nN][sS][bB][oO][rR][oO]|[gG][hH][oO][sS][tT][wW][hH][iI][tT][eE]|[gG][oO][lL][dD]|[gG][oO][lL][dD][eE][nN][rR][oO][dD]|[gG][rR][aA][yY]|[gG][rR][aA][yY][tT][eE][xX][tT]|[gG][rR][eE][eE][nN]|[gG][rR][eE][eE][nN][yY][eE][lL][lL][oO][wW]|[gG][rR][eE][yY]|[hH][iI][gG][hH][lL][iI][gG][hH][tT]|[hH][iI][gG][hH][lL][iI][gG][hH][tT][tT][eE][xX][tT]|[hH][oO][nN][eE][yY][dD][eE][wW]|[hH][oO][tT][pP][iI][nN][kK]|[iI][nN][aA][cC][tT][iI][vV][eE][bB][oO][rR][dD][eE][rR]|[iI][nN][aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN]|[iI][nN][aA][cC][tT][iI][vV][eE][cC][aA][pP][tT][iI][oO][nN][tT][eE][xX][tT]|[iI][nN][dD][iI][aA][nN][rR][eE][dD]|[iI][nN][dD][iI][gG][oO]|[iI][nN][fF][oO][bB][aA][cC][kK][gG][rR][oO][uU][nN][dD]|[iI][nN][fF][oO][tT][eE][xX][tT]|[iI][vV][oO][rR][yY]|[kK][hH][aA][kK][iI]|[lL][aA][vV][eE][nN][dD][eE][rR]|[lL][aA][vV][eE][nN][dD][eE][rR][bB][lL][uU][sS][hH]|[lL][aA][wW][nN][gG][rR][eE][eE][nN]|[lL][eE][mM][oO][nN][cC][hH][iI][fF][fF][oO][nN]|[lL][iI][gG][hH][tT][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][cC][oO][rR][aA][lL]|[lL][iI][gG][hH][tT][cC][yY][aA][nN]|[lL][iI][gG][hH][tT][gG][oO][lL][dD][eE][nN][rR][oO][dD][yY][eE][lL][lL][oO][wW]|[lL][iI][gG][hH][tT][gG][rR][aA][yY]|[lL][iI][gG][hH][tT][gG][rR][eE][eE][nN]|[lL][iI][gG][hH][tT][gG][rR][eE][yY]|[lL][iI][gG][hH][tT][pP][iI][nN][kK]|[lL][iI][gG][hH][tT][sS][aA][lL][mM][oO][nN]|[lL][iI][gG][hH][tT][sS][eE][aA][gG][rR][eE][eE][nN]|[lL][iI][gG][hH][tT][sS][kK][yY][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][sS][lL][aA][tT][eE][gG][rR][aA][yY]|[lL][iI][gG][hH][tT][sS][lL][aA][tT][eE][gG][rR][eE][yY]|[lL][iI][gG][hH][tT][sS][tT][eE][eE][lL][bB][lL][uU][eE]|[lL][iI][gG][hH][tT][yY][eE][lL][lL][oO][wW]|[lL][iI][mM][eE]|[lL][iI][mM][eE][gG][rR][eE][eE][nN]|[lL][iI][nN][eE][nN]|[lL][iI][nN][kK][tT][eE][xX][tT]|[mM][aA][gG][eE][nN][tT][aA]|[mM][aA][rR][kK]|[mM][aA][rR][kK][tT][eE][xX][tT]|[mM][aA][rR][oO][oO][nN]|[mM][eE][dD][iI][uU][mM][aA][qQ][uU][aA][mM][aA][rR][iI][nN][eE]|[mM][eE][dD][iI][uU][mM][bB][lL][uU][eE]|[mM][eE][dD][iI][uU][mM][oO][rR][cC][hH][iI][dD]|[mM][eE][dD][iI][uU][mM][pP][uU][rR][pP][lL][eE]|[mM][eE][dD][iI][uU][mM][sS][eE][aA][gG][rR][eE][eE][nN]|[mM][eE][dD][iI][uU][mM][sS][lL][aA][tT][eE][bB][lL][uU][eE]|[mM][eE][dD][iI][uU][mM][sS][pP][rR][iI][nN][gG][gG][rR][eE][eE][nN]|[mM][eE][dD][iI][uU][mM][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[mM][eE][dD][iI][uU][mM][vV][iI][oO][lL][eE][tT][rR][eE][dD]|[mM][eE][nN][uU]|[mM][eE][nN][uU][tT][eE][xX][tT]|[mM][iI][dD][nN][iI][gG][hH][tT][bB][lL][uU][eE]|[mM][iI][nN][tT][cC][rR][eE][aA][mM]|[mM][iI][sS][tT][yY][rR][oO][sS][eE]|[mM][oO][cC][cC][aA][sS][iI][nN]|[nN][aA][vV][aA][jJ][oO][wW][hH][iI][tT][eE]|[nN][aA][vV][yY]|[nN][oO][nN][eE]|[oO][lL][dD][lL][aA][cC][eE]|[oO][lL][iI][vV][eE]|[oO][lL][iI][vV][eE][dD][rR][aA][bB]|[oO][rR][aA][nN][gG][eE]|[oO][rR][aA][nN][gG][eE][rR][eE][dD]|[oO][rR][cC][hH][iI][dD]|[pP][aA][lL][eE][gG][oO][lL][dD][eE][nN][rR][oO][dD]|[pP][aA][lL][eE][gG][rR][eE][eE][nN]|[pP][aA][lL][eE][tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[pP][aA][lL][eE][vV][iI][oO][lL][eE][tT][rR][eE][dD]|[pP][aA][pP][aA][yY][aA][wW][hH][iI][pP]|[pP][eE][aA][cC][hH][pP][uU][fF][fF]|[pP][eE][rR][uU]|[pP][iI][nN][kK]|[pP][lL][uU][mM]|[pP][oO][wW][dD][eE][rR][bB][lL][uU][eE]|[pP][uU][rR][pP][lL][eE]|[rR][eE][bB][eE][cC][cC][aA][pP][uU][rR][pP][lL][eE]|[rR][eE][dD]|[rR][oO][sS][yY][bB][rR][oO][wW][nN]|[rR][oO][yY][aA][lL][bB][lL][uU][eE]|[sS][aA][dD][dD][lL][eE][bB][rR][oO][wW][nN]|[sS][aA][lL][mM][oO][nN]|[sS][aA][nN][dD][yY][bB][rR][oO][wW][nN]|[sS][cC][rR][oO][lL][lL][bB][aA][rR]|[sS][eE][aA][gG][rR][eE][eE][nN]|[sS][eE][aA][sS][hH][eE][lL][lL]|[sS][eE][lL][eE][cC][tT][eE][dD][iI][tT][eE][mM]|[sS][eE][lL][eE][cC][tT][eE][dD][iI][tT][eE][mM][tT][eE][xX][tT]|[sS][iI][eE][nN][nN][aA]|[sS][iI][lL][vV][eE][rR]|[sS][kK][yY][bB][lL][uU][eE]|[sS][lL][aA][tT][eE][bB][lL][uU][eE]|[sS][lL][aA][tT][eE][gG][rR][aA][yY]|[sS][lL][aA][tT][eE][gG][rR][eE][yY]|[sS][nN][oO][wW]|[sS][pP][rR][iI][nN][gG][gG][rR][eE][eE][nN]|[sS][rR][gG][bB]|[sS][tT][eE][eE][lL][bB][lL][uU][eE]|[tT][aA][nN]|[tT][eE][aA][lL]|[tT][hH][iI][sS][tT][lL][eE]|[tT][hH][rR][eE][eE][dD][dD][aA][rR][kK][sS][hH][aA][dD][oO][wW]|[tT][hH][rR][eE][eE][dD][fF][aA][cC][eE]|[tT][hH][rR][eE][eE][dD][hH][iI][gG][hH][lL][iI][gG][hH][tT]|[tT][hH][rR][eE][eE][dD][lL][iI][gG][hH][tT][sS][hH][aA][dD][oO][wW]|[tT][hH][rR][eE][eE][dD][sS][hH][aA][dD][oO][wW]|[tT][oO][mM][aA][tT][oO]|[tT][rR][aA][nN][sS][pP][aA][rR][eE][nN][tT]|[tT][uU][rR][qQ][uU][oO][iI][sS][eE]|[vV][iI][oO][lL][eE][tT]|[vV][iI][sS][iI][tT][eE][dD][tT][eE][xX][tT]|[wW][hH][eE][aA][tT]|[wW][hH][iI][tT][eE]|[wW][hH][iI][tT][eE][sS][mM][oO][kK][eE]|[wW][iI][nN][dD][oO][wW]|[wW][iI][nN][dD][oO][wW][fF][rR][aA][mM][eE]|[wW][iI][nN][dD][oO][wW][tT][eE][xX][tT]|[xX][yY][zZ]|[yY][eE][lL][lL][oO][wW]|[yY][eE][lL][lL][oO][wW][gG][rR][eE][eE][nN])))*)$
            /**
             * Typography §text-transform: values MUST follow the <text-transform-list> grammar and remain locale-sensitive.
             * Text transform
             * Keyword list matching the CSS text-transform grammar per Typography §text-transform.
             */
            textTransform?: string; // ^(?:(?:[Ii][Nn][Hh][Ee][Rr][Ii][Tt]|[Ii][Nn][Ii][Tt][Ii][Aa][Ll]|[Uu][Nn][Ss][Ee][Tt]|[Rr][Ee][Vv][Ee][Rr][Tt](?:-[Ll][Aa][Yy][Ee][Rr])?)|(?:[Vv][Aa][Rr]|[Ee][Nn][Vv])\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)|(?:(?:[Nn][Oo][Nn][Ee]|[Cc][Aa][Pp][Ii][Tt][Aa][Ll][Ii][Zz][Ee]|[Uu][Pp][Pp][Ee][Rr][Cc][Aa][Ss][Ee]|[Ll][Oo][Ww][Ee][Rr][Cc][Aa][Ss][Ee]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Ff][Uu][Ll][Ll]-[Ss][Ii][Zz][Ee]-[Kk][Aa][Nn][Aa]|[Mm][Aa][Tt][Hh]-[Aa][Uu][Tt][Oo]|[Mm][Aa][Tt][Hh](?:-[A-Za-z]+)+))(?:\s+(?:[Nn][Oo][Nn][Ee]|[Cc][Aa][Pp][Ii][Tt][Aa][Ll][Ii][Zz][Ee]|[Uu][Pp][Pp][Ee][Rr][Cc][Aa][Ss][Ee]|[Ll][Oo][Ww][Ee][Rr][Cc][Aa][Ss][Ee]|[Ff][Uu][Ll][Ll]-[Ww][Ii][Dd][Tt][Hh]|[Ff][Uu][Ll][Ll]-[Ss][Ii][Zz][Ee]-[Kk][Aa][Nn][Aa]|[Mm][Aa][Tt][Hh]-[Aa][Uu][Tt][Oo]|[Mm][Aa][Tt][Hh](?:-[A-Za-z]+)+))*)$
            color?: ColorReference;
            /**
             * MUST contain OpenType feature tags per CSS font-feature-settings and the OpenType registry.
             */
            fontFeatures?: string /* ^[A-Za-z0-9]{4}$ */[];
            underlineThickness?: FontDimensionReference;
            underlineOffset?: FontDimensionReference;
            overlineThickness?: FontDimensionReference;
            overlineOffset?: FontDimensionReference;
        }
        /**
         * Typography §typography and Token types §value: typography tokens MAY embed direct values, $ref aliases, or functions.
         * Typography value entry
         * Literal typography payload, alias, or computed expression per Typography §typography.
         */
        export type TypographyValueEntry = /**
         * Typography §typography and Token types §value: typography tokens MAY embed direct values, $ref aliases, or functions.
         * Typography value entry
         * Literal typography payload, alias, or computed expression per Typography §typography.
         */ Typography | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Typography fallback list
         * Ordered fallback list of typography values evaluated per Token types §value.
         */
        export type TypographyValueFallback = [
            /**
             * Typography §typography and Token types §value: typography tokens MAY embed direct values, $ref aliases, or functions.
             * Typography value entry
             * Literal typography payload, alias, or computed expression per Typography §typography.
             */
            TypographyValueEntry,
            ...TypographyValueEntry[]
        ];
        export interface ZIndex {
            /**
             * MUST name a stacking context primitive such as css.z-index, ios.calayer.z-position, android.view.z, or android.view.translationz as defined by CSS Positioned Layout Module Level 3 (css-position-3#propdef-z-index), CALayer.zPosition (IOS-CALAYER), and Android View Z APIs (ANDROID-VIEW-SETZ, ANDROID-VIEW-TRANSLATIONZ).
             * Z-index context identifier
             * Platform-qualified stacking context such as css.z-index, ios.calayer.z-position, or android.view.translationz.
             */
            zIndexType: string; // ^(?:css|ios|android)(?:\.[a-z0-9]+(?:-[a-z0-9]+)*)+$
            /**
             * MUST conform to CSS <integer> (css-position-3#propdef-z-index, css-values-4#integer-value), CALayer.zPosition (IOS-CALAYER), or Android View Z APIs (ANDROID-VIEW-SETZ, ANDROID-VIEW-TRANSLATIONZ) depending on the referenced platform.
             */
            value: number;
        }
        /**
         * Token types §z-index and §value: z-index tokens MAY embed direct values, $ref aliases, or functions.
         * Z-index value entry
         * Stacking context magnitude, alias, or computed expression per Token types §z-index.
         */
        export type ZIndexValueEntry = /**
         * Token types §z-index and §value: z-index tokens MAY embed direct values, $ref aliases, or functions.
         * Z-index value entry
         * Stacking context magnitude, alias, or computed expression per Token types §z-index.
         */ ZIndex | /**
         * Token types §value: alias objects contain only $ref and MUST resolve to the same $type.
         * Pointer alias
         * Object aliasing another token via $ref per Token types §value.
         */ Reference | /**
         * Token types §value: $value MAY be a function object with fn and optional parameters members.
         * Function expression
         * Computed value wrapper with a function name and optional parameters per Token types §value.
         */ Function;
        /**
         * Token types §value: fallback sequences evaluate candidates until one resolves.
         * Z-index fallback list
         * Ordered fallback list of z-index values evaluated per Token types §value.
         */
        export type ZIndexValueFallback = [
            /**
             * Token types §z-index and §value: z-index tokens MAY embed direct values, $ref aliases, or functions.
             * Z-index value entry
             * Stacking context magnitude, alias, or computed expression per Token types §z-index.
             */
            ZIndexValueEntry,
            ...ZIndexValueEntry[]
        ];
    }
}
export interface AngleDimension extends CoreJson.Definitions.AngleDimension {
}
export type AngleDimensionReference = CoreJson.Definitions.AngleDimensionReference;
export interface Border extends CoreJson.Definitions.Border {
}
export type BorderCornerRadius = CoreJson.Definitions.BorderCornerRadius;
export type BorderValueEntry = CoreJson.Definitions.BorderValueEntry;
export type BorderValueFallback = CoreJson.Definitions.BorderValueFallback;
export type Collection = CoreJson.Definitions.Collection;
export interface Color extends CoreJson.Definitions.Color {
}
export type ColorHintLengthString = CoreJson.Definitions.ColorHintLengthString;
export type ColorReference = CoreJson.Definitions.ColorReference;
export type ColorStopLengthString = CoreJson.Definitions.ColorStopLengthString;
export type ColorValueEntry = CoreJson.Definitions.ColorValueEntry;
export type ColorValueFallback = CoreJson.Definitions.ColorValueFallback;
export type ContextIdentifier = CoreJson.Definitions.ContextIdentifier;
export type CssFamilyName = CoreJson.Definitions.CssFamilyName;
export type CssIdent = CoreJson.Definitions.CssIdent;
export interface Cursor extends CoreJson.Definitions.Cursor {
}
export type CursorValueEntry = CoreJson.Definitions.CursorValueEntry;
export type CursorValueFallback = CoreJson.Definitions.CursorValueFallback;
export interface Dimension extends CoreJson.Definitions.Dimension {
}
export type DimensionReference = CoreJson.Definitions.DimensionReference;
export type DimensionValueEntry = CoreJson.Definitions.DimensionValueEntry;
export type DimensionValueFallback = CoreJson.Definitions.DimensionValueFallback;
export interface Duration extends CoreJson.Definitions.Duration {
}
export type DurationValueEntry = CoreJson.Definitions.DurationValueEntry;
export type DurationValueFallback = CoreJson.Definitions.DurationValueFallback;
export interface Easing extends CoreJson.Definitions.Easing {
}
export type EasingValueEntry = CoreJson.Definitions.EasingValueEntry;
export type EasingValueFallback = CoreJson.Definitions.EasingValueFallback;
export interface Elevation extends CoreJson.Definitions.Elevation {
}
export type ElevationValueEntry = CoreJson.Definitions.ElevationValueEntry;
export type ElevationValueFallback = CoreJson.Definitions.ElevationValueFallback;
export interface Extensions extends CoreJson.Definitions.Extensions {
}
export type Fallback = CoreJson.Definitions.Fallback;
export type FallbackEntry = CoreJson.Definitions.FallbackEntry;
export interface FallbackEntryCore extends CoreJson.Definitions.FallbackEntryCore {
}
export interface Filter extends CoreJson.Definitions.Filter {
}
export type FilterValueEntry = CoreJson.Definitions.FilterValueEntry;
export type FilterValueFallback = CoreJson.Definitions.FilterValueFallback;
export interface Font extends CoreJson.Definitions.Font {
}
export type FontDimension = CoreJson.Definitions.FontDimension;
export type FontDimensionReference = CoreJson.Definitions.FontDimensionReference;
export interface FontFace extends CoreJson.Definitions.FontFace {
}
export type FontFaceValueEntry = CoreJson.Definitions.FontFaceValueEntry;
export type FontFaceValueFallback = CoreJson.Definitions.FontFaceValueFallback;
export type FontStretchString = CoreJson.Definitions.FontStretchString;
export type FontStyleString = CoreJson.Definitions.FontStyleString;
export type FontValueEntry = CoreJson.Definitions.FontValueEntry;
export type FontValueFallback = CoreJson.Definitions.FontValueFallback;
export type FontVariantString = CoreJson.Definitions.FontVariantString;
export type FontWeightString = CoreJson.Definitions.FontWeightString;
export interface Function extends CoreJson.Definitions.Function {
}
export type FunctionParameter = CoreJson.Definitions.FunctionParameter;
export interface Gradient extends CoreJson.Definitions.Gradient {
}
export type GradientEndingShape = CoreJson.Definitions.GradientEndingShape;
export type GradientLineAngle = CoreJson.Definitions.GradientLineAngle;
export type GradientPosition = CoreJson.Definitions.GradientPosition;
export type GradientValueEntry = CoreJson.Definitions.GradientValueEntry;
export type GradientValueFallback = CoreJson.Definitions.GradientValueFallback;
export type HashString = CoreJson.Definitions.HashString;
export interface LengthDimension extends CoreJson.Definitions.LengthDimension {
}
export type LengthDimensionReference = CoreJson.Definitions.LengthDimensionReference;
export type LifecycleMetadata = CoreJson.Definitions.LifecycleMetadata;
export type LineHeight = CoreJson.Definitions.LineHeight;
export type LineHeightValueEntry = CoreJson.Definitions.LineHeightValueEntry;
export type LineHeightValueFallback = CoreJson.Definitions.LineHeightValueFallback;
export interface MetadataMembers extends CoreJson.Definitions.MetadataMembers {
}
export interface Motion extends CoreJson.Definitions.Motion {
}
export type MotionAngle = CoreJson.Definitions.MotionAngle;
export type MotionLength = CoreJson.Definitions.MotionLength;
export type MotionOrigin = CoreJson.Definitions.MotionOrigin;
export interface MotionPathPoint extends CoreJson.Definitions.MotionPathPoint {
}
export type MotionPathPosition = CoreJson.Definitions.MotionPathPosition;
export type MotionScaleFactor = CoreJson.Definitions.MotionScaleFactor;
export type MotionValueEntry = CoreJson.Definitions.MotionValueEntry;
export type MotionValueFallback = CoreJson.Definitions.MotionValueFallback;
export type NamespacedFunctionIdentifier = CoreJson.Definitions.NamespacedFunctionIdentifier;
export type Node = CoreJson.Definitions.Node;
export type NonEmptyArray = CoreJson.Definitions.NonEmptyArray;
export interface Opacity extends CoreJson.Definitions.Opacity {
}
export type OpacityValueEntry = CoreJson.Definitions.OpacityValueEntry;
export type OpacityValueFallback = CoreJson.Definitions.OpacityValueFallback;
export type Override = CoreJson.Definitions.Override;
export interface OverrideCore extends CoreJson.Definitions.OverrideCore {
}
export type PlatformIdentifier = CoreJson.Definitions.PlatformIdentifier;
export type Pointer = CoreJson.Definitions.Pointer;
export interface Reference extends CoreJson.Definitions.Reference {
}
export type Shadow = CoreJson.Definitions.Shadow;
export interface ShadowLayer extends CoreJson.Definitions.ShadowLayer {
}
export type ShadowValueEntry = CoreJson.Definitions.ShadowValueEntry;
export interface StrokeStyle extends CoreJson.Definitions.StrokeStyle {
}
export type StrokeStyleValueEntry = CoreJson.Definitions.StrokeStyleValueEntry;
export type StrokeStyleValueFallback = CoreJson.Definitions.StrokeStyleValueFallback;
export type Tags = CoreJson.Definitions.Tags;
export type TextDecorationShorthand = CoreJson.Definitions.TextDecorationShorthand;
export type TextTransformList = CoreJson.Definitions.TextTransformList;
export type Token = CoreJson.Definitions.Token;
export type TokenCore = CoreJson.Definitions.TokenCore;
export interface TokenMembers extends CoreJson.Definitions.TokenMembers {
}
export type TrimmedString = CoreJson.Definitions.TrimmedString;
export type TypeIdentifier = CoreJson.Definitions.TypeIdentifier;
export interface Typography extends CoreJson.Definitions.Typography {
}
export type TypographyValueEntry = CoreJson.Definitions.TypographyValueEntry;
export type TypographyValueFallback = CoreJson.Definitions.TypographyValueFallback;
export interface ZIndex extends CoreJson.Definitions.ZIndex {
}
export type ZIndexValueEntry = CoreJson.Definitions.ZIndexValueEntry;
export type ZIndexValueFallback = CoreJson.Definitions.ZIndexValueFallback;
export type TokenMemberMap = {
    [K in PropertyKey as K extends string ? K extends `$${string}` ? never : K : never]: CoreJson.Definitions.Node;
};
export type TokenOrCollectionNode = CoreJson.Definitions.Node;
export type DesignTokenInterchangeFormat = TokenMemberMap & {
    "$schema"?: CoreJson["$schema"];
    "$description"?: CoreJson["$description"];
    "$version"?: CoreJson["$version"];
    "$extensions"?: CoreJson["$extensions"];
    "$overrides"?: CoreJson["$overrides"];
};
