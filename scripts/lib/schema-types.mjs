import fs from 'fs/promises';
import path from 'path';
import { execFileSync } from 'child_process';
import dtsGeneratorModule from 'dtsgenerator';
const { default: dtsgenerator, parseSchema } = dtsGeneratorModule;
import ts from 'typescript';

export const bannerComment = `/* eslint-disable */\n/**\n * This file was automatically generated by dtsgenerator.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSON Schema file,\n * and run the build to regenerate this file.\n */`;

function normalizeSchemaTypes(source) {
  return `${source.trimEnd()}\n`;
}

function clone(value) {
  return JSON.parse(JSON.stringify(value));
}

function convertRefs(value) {
  if (Array.isArray(value)) {
    return value.map(convertRefs);
  }
  if (value && typeof value === 'object') {
    const result = {};
    for (const [key, child] of Object.entries(value)) {
      const nextKey = key === '$defs' ? 'definitions' : key;
      result[nextKey] = convertRefs(child);
    }
    if (typeof result.$ref === 'string') {
      result.$ref = result.$ref.replace('#/$defs/', '#/definitions/');
      if (result.$ref === '#/$defs') {
        result.$ref = '#/definitions';
      }
    }
    return result;
  }
  return value;
}

function extractTokenMemberPrefix(schema) {
  const tokenMembers = schema?.definitions?.['token-members'];
  if (!tokenMembers) {
    throw new Error('Schema is missing definitions.token-members definition');
  }
  const patternProperties = tokenMembers.patternProperties;
  if (!patternProperties || Object.keys(patternProperties).length === 0) {
    throw new Error('Token member definition must declare a patternProperties entry');
  }
  const patterns = Object.keys(patternProperties);
  if (patterns.length !== 1) {
    throw new Error('Token member definition must declare exactly one pattern constraint');
  }
  const pattern = patterns[0];
  const match = pattern.match(/^\^\(\?!\\(.).*\)$/);
  if (!match) {
    throw new Error(`Unsupported token member pattern: ${pattern}`);
  }
  return match[1];
}

function hasDeclareModifier(node) {
  return Boolean(
    node.modifiers?.some((modifier) => modifier.kind === ts.SyntaxKind.DeclareKeyword)
  );
}

function replaceDeclareWithExport(node, factory) {
  if (!node.modifiers) {
    return node;
  }
  const modifiers = node.modifiers.filter(
    (modifier) => modifier.kind !== ts.SyntaxKind.DeclareKeyword
  );
  modifiers.unshift(factory.createModifier(ts.SyntaxKind.ExportKeyword));
  return modifiers;
}

function addHeritageClause(heritageClauses, clause) {
  if (!heritageClauses || heritageClauses.length === 0) {
    return ts.factory.createNodeArray([clause]);
  }
  const clauses = [...heritageClauses];
  const extendsIndex = clauses.findIndex((item) => item.token === ts.SyntaxKind.ExtendsKeyword);
  if (extendsIndex === -1) {
    clauses.push(clause);
    return ts.factory.createNodeArray(clauses);
  }
  const target = clauses[extendsIndex];
  clauses[extendsIndex] = ts.factory.updateHeritageClause(target, [
    ...target.types,
    ...clause.types
  ]);
  return ts.factory.createNodeArray(clauses);
}

function transformInterface(statement, factory, context) {
  let members = statement.members;
  let heritageClauses = statement.heritageClauses;
  let modifiers = statement.modifiers;

  if (hasDeclareModifier(statement)) {
    modifiers = replaceDeclareWithExport(statement, factory);
  }

  if (
    context.length === 2 &&
    context[0] === 'CoreJson' &&
    context[1] === 'Definitions' &&
    statement.name.text === 'Collection'
  ) {
    const metadataMembers = members.filter((member) => !ts.isIndexSignatureDeclaration(member));
    const alias = factory.createTypeAliasDeclaration(
      modifiers,
      statement.name,
      undefined,
      factory.createIntersectionTypeNode([
        factory.createTypeReferenceNode(factory.createIdentifier('TokenMemberMap'), undefined),
        factory.createTypeLiteralNode(metadataMembers)
      ])
    );
    alias.jsDoc = statement.jsDoc;
    return alias;
  }

  if (context.length === 0 && statement.name.text === 'CoreJson') {
    members = members.filter((member) => !ts.isIndexSignatureDeclaration(member));
  }

  return factory.updateInterfaceDeclaration(
    statement,
    modifiers,
    statement.name,
    statement.typeParameters,
    heritageClauses,
    members
  );
}

function transformModule(statement, factory, context) {
  let modifiers = statement.modifiers;
  if (hasDeclareModifier(statement)) {
    modifiers = replaceDeclareWithExport(statement, factory);
  }

  const body = statement.body;
  if (!body || !ts.isModuleBlock(body)) {
    return factory.updateModuleDeclaration(statement, modifiers, statement.name, body);
  }

  const moduleContext = [...context, statement.name.text];
  const updatedStatements = body.statements.map((node) =>
    transformStatement(node, factory, moduleContext)
  );
  const updatedBody = factory.updateModuleBlock(body, factory.createNodeArray(updatedStatements));
  return factory.updateModuleDeclaration(statement, modifiers, statement.name, updatedBody);
}

function transformStatement(statement, factory, context = []) {
  if (ts.isInterfaceDeclaration(statement)) {
    return transformInterface(statement, factory, context);
  }
  if (ts.isModuleDeclaration(statement)) {
    return transformModule(statement, factory, context);
  }
  return statement;
}

function toQualifiedName(factory, parts) {
  return parts
    .slice(1)
    .reduce(
      (expr, part) => factory.createQualifiedName(expr, factory.createIdentifier(part)),
      factory.createIdentifier(parts[0])
    );
}

function toPropertyAccess(factory, parts) {
  return parts
    .slice(1)
    .reduce(
      (expr, part) => factory.createPropertyAccessExpression(expr, part),
      factory.createIdentifier(parts[0])
    );
}

function createDefinitionAlias(factory, definition) {
  const baseParts = ['CoreJson', 'Definitions', definition.name];
  if (definition.kind === 'interface') {
    return factory.createInterfaceDeclaration(
      [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      factory.createIdentifier(definition.name),
      undefined,
      [
        factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
          factory.createExpressionWithTypeArguments(toPropertyAccess(factory, baseParts), undefined)
        ])
      ],
      []
    );
  }
  return factory.createTypeAliasDeclaration(
    [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    factory.createIdentifier(definition.name),
    undefined,
    factory.createTypeReferenceNode(toQualifiedName(factory, baseParts), undefined)
  );
}

function createTemplateLiteral(factory, prefix) {
  return factory.createTemplateLiteralType(factory.createTemplateHead(prefix), [
    factory.createTemplateLiteralTypeSpan(
      factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
      factory.createTemplateTail('')
    )
  ]);
}

function createTokenMemberMapAlias(factory, prefix) {
  const template = createTemplateLiteral(factory, prefix);
  const typeParam = factory.createTypeParameterDeclaration(
    undefined,
    factory.createIdentifier('K'),
    factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
    undefined
  );
  const filteredKey = factory.createConditionalTypeNode(
    factory.createTypeReferenceNode(factory.createIdentifier('K'), undefined),
    template,
    factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword),
    factory.createTypeReferenceNode(factory.createIdentifier('K'), undefined)
  );
  return factory.createTypeAliasDeclaration(
    [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    factory.createIdentifier('TokenMemberMap'),
    undefined,
    factory.createMappedTypeNode(
      undefined,
      typeParam,
      filteredKey,
      factory.createToken(ts.SyntaxKind.QuestionToken),
      factory.createTypeReferenceNode(
        toQualifiedName(factory, ['CoreJson', 'Definitions', 'Node']),
        undefined
      ),
      undefined
    )
  );
}

function createDesignTokenInterchangeFormatAlias(factory) {
  const metadataProperties = ['$schema', '$description', '$version', '$extensions', '$overrides'];
  const metadataMembers = metadataProperties.map((property) =>
    factory.createPropertySignature(
      undefined,
      factory.createStringLiteral(property),
      factory.createToken(ts.SyntaxKind.QuestionToken),
      factory.createIndexedAccessTypeNode(
        factory.createTypeReferenceNode(factory.createIdentifier('CoreJson'), undefined),
        factory.createLiteralTypeNode(factory.createStringLiteral(property))
      )
    )
  );
  return factory.createTypeAliasDeclaration(
    [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    factory.createIdentifier('DesignTokenInterchangeFormat'),
    undefined,
    factory.createIntersectionTypeNode([
      factory.createTypeReferenceNode(factory.createIdentifier('TokenMemberMap'), undefined),
      factory.createTypeLiteralNode(metadataMembers)
    ])
  );
}

function createTokenOrCollectionNodeAlias(factory) {
  return factory.createTypeAliasDeclaration(
    [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    factory.createIdentifier('TokenOrCollectionNode'),
    undefined,
    factory.createTypeReferenceNode(
      toQualifiedName(factory, ['CoreJson', 'Definitions', 'Node']),
      undefined
    )
  );
}

function gatherDefinitionMetadata(sourceFile) {
  const definitionsNamespace = sourceFile.statements.find(
    (statement) => ts.isModuleDeclaration(statement) && statement.name.text === 'CoreJson'
  );
  if (!definitionsNamespace || !ts.isModuleDeclaration(definitionsNamespace)) {
    throw new Error('Failed to locate CoreJson namespace in generated declarations');
  }
  const namespaceBody = definitionsNamespace.body;
  if (!namespaceBody || !ts.isModuleBlock(namespaceBody)) {
    throw new Error('CoreJson namespace body is not a module block');
  }
  const definitions = namespaceBody.statements.find(
    (statement) => ts.isModuleDeclaration(statement) && statement.name.text === 'Definitions'
  );
  if (!definitions || !ts.isModuleDeclaration(definitions)) {
    throw new Error('Failed to locate CoreJson.Definitions namespace');
  }
  const definitionsBody = definitions.body;
  if (!definitionsBody || !ts.isModuleBlock(definitionsBody)) {
    throw new Error('CoreJson.Definitions body is not a module block');
  }
  return definitionsBody.statements
    .filter(
      (statement) => ts.isInterfaceDeclaration(statement) || ts.isTypeAliasDeclaration(statement)
    )
    .map((statement) => ({
      name: statement.name.text,
      kind: ts.isInterfaceDeclaration(statement) ? 'interface' : 'type'
    }));
}

async function generateSchemaTypes(schemaPath, options = {}) {
  const schema = JSON.parse(await fs.readFile(schemaPath, 'utf8'));
  const converted = convertRefs(clone(schema));
  const prefix = extractTokenMemberPrefix(converted);
  const generated = await dtsgenerator({
    contents: [parseSchema(converted, schemaPath)],
    config: {
      input: { files: [], urls: [], stdin: false },
      plugins: {
        '@dtsgenerator/replace-namespace': {
          map: [{ from: ['DtifLapidistNet', 'Schema'], to: [] }]
        }
      }
    }
  });
  const sourceFile = ts.createSourceFile(
    'schema.d.ts',
    generated,
    ts.ScriptTarget.Latest,
    true,
    ts.ScriptKind.TS
  );
  const factory = ts.factory;
  const definitionMetadata = gatherDefinitionMetadata(sourceFile).map((definition) =>
    definition.name === 'Collection' ? { ...definition, kind: 'type' } : definition
  );
  const rootStatements = Array.from(sourceFile.statements).map((statement) =>
    transformStatement(statement, factory)
  );
  const aliasStatements = [
    ...definitionMetadata.map((definition) => createDefinitionAlias(factory, definition)),
    createTokenMemberMapAlias(factory, prefix),
    createTokenOrCollectionNodeAlias(factory),
    createDesignTokenInterchangeFormatAlias(factory)
  ];
  const updatedFile = factory.updateSourceFile(
    sourceFile,
    factory.createNodeArray([...rootStatements, ...aliasStatements])
  );
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const printed = printer.printFile(updatedFile);
  const outputPath = path.join(path.dirname(schemaPath), 'index.d.ts');
  let formatted;
  try {
    formatted = execFileSync(
      process.execPath,
      [
        path.join(process.cwd(), 'node_modules', 'prettier', 'bin', 'prettier.cjs'),
        '--stdin-filepath',
        outputPath
      ],
      {
        input: `${bannerComment}\n${printed}`,
        encoding: 'utf8'
      }
    );
  } catch (error) {
    throw new Error(`Prettier failed to format schema types: ${error.message}`);
  }
  return normalizeSchemaTypes(formatted);
}

export async function compileSchemaTypes(schemaPath, options = {}) {
  const absolutePath = options.cwd ? path.resolve(options.cwd, schemaPath) : schemaPath;
  return generateSchemaTypes(absolutePath, options);
}
