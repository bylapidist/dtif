import fs from 'fs/promises';
import { compileFromFile } from 'json-schema-to-typescript';
import ts from 'typescript';

export const bannerComment = `/* eslint-disable */\n/**\n * This file was automatically generated by json-schema-to-typescript.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n * and run json-schema-to-typescript to regenerate this file.\n */`;

function normalizeIndentation(source) {
  return source.replace(/\n( +)/g, (match, spaces) => {
    const levels = spaces.length / 4;
    if (!Number.isInteger(levels) || levels === 0) {
      return match;
    }
    return `\n${'  '.repeat(levels)}`;
  });
}

function normalizeSchemaTypes(source) {
  return `${normalizeIndentation(source).trimEnd()}\n`;
}

function extractTokenMemberPrefix(schema) {
  const tokenMembers = schema?.$defs?.['token-members'];
  if (!tokenMembers) {
    throw new Error('Schema is missing $defs.token-members definition');
  }

  const patternProperties = tokenMembers.patternProperties;
  if (!patternProperties || Object.keys(patternProperties).length === 0) {
    throw new Error(
      'Schema token-members definition must declare patternProperties for member keys'
    );
  }

  const patterns = Object.keys(patternProperties);
  if (patterns.length !== 1) {
    throw new Error(
      'Schema token-members patternProperties must include exactly one pattern constraint'
    );
  }

  const pattern = patterns[0];
  const match = pattern.match(/^\^\(\?!\\(.).*\)$/);
  if (!match) {
    throw new Error(`Unsupported token member pattern: ${pattern}`);
  }

  return match[1];
}

function createExcludedKeyTemplate(factory, prefix) {
  return factory.createTemplateLiteralType(factory.createTemplateHead(prefix), [
    factory.createTemplateLiteralTypeSpan(
      factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
      factory.createTemplateTail('')
    )
  ]);
}

function createFilteredTokenMemberType(factory, prefix) {
  const template = createExcludedKeyTemplate(factory, prefix);
  const typeParameter = factory.createTypeParameterDeclaration(
    undefined,
    factory.createIdentifier('K'),
    factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
    undefined
  );
  const filteredKey = factory.createConditionalTypeNode(
    factory.createTypeReferenceNode(factory.createIdentifier('K'), undefined),
    template,
    factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword),
    factory.createTypeReferenceNode(factory.createIdentifier('K'), undefined)
  );

  return factory.createMappedTypeNode(
    undefined,
    typeParameter,
    filteredKey,
    factory.createToken(ts.SyntaxKind.QuestionToken),
    factory.createTypeReferenceNode(factory.createIdentifier('TokenOrCollectionNode'), undefined),
    undefined
  );
}

function updateDesignTokenInterchangeFormat(node, factory) {
  if (!ts.isIntersectionTypeNode(node.type)) {
    return node;
  }

  let modified = false;
  const updatedTypes = node.type.types.map((part) => {
    if (!ts.isTypeLiteralNode(part)) {
      return part;
    }
    const filteredMembers = part.members.filter(
      (member) => !ts.isIndexSignatureDeclaration(member)
    );
    if (filteredMembers.length === part.members.length) {
      return part;
    }
    modified = true;
    return factory.updateTypeLiteralNode(part, filteredMembers);
  });

  if (!modified) {
    return node;
  }

  const intersection = factory.updateIntersectionTypeNode(node.type, updatedTypes);
  const updated = factory.updateTypeAliasDeclaration(
    node,
    node.modifiers,
    node.name,
    node.typeParameters,
    intersection
  );
  ts.setOriginalNode(updated, node);
  return updated;
}

function replaceTokenMemberInterface(node, factory, prefix) {
  const filteredType = createFilteredTokenMemberType(factory, prefix);
  const alias = factory.createTypeAliasDeclaration(
    node.modifiers,
    node.name,
    undefined,
    filteredType
  );
  ts.setOriginalNode(alias, node);
  return alias;
}

export function applySchemaTypeTransforms(source, schema) {
  const sourceFile = ts.createSourceFile(
    'schema-types.d.ts',
    source,
    ts.ScriptTarget.Latest,
    true,
    ts.ScriptKind.TS
  );
  const tokenMemberPrefix = extractTokenMemberPrefix(schema);

  const transformer = (context) => {
    const { factory } = context;
    const visit = (node) => {
      if (ts.isTypeAliasDeclaration(node) && node.name.text === 'DesignTokenInterchangeFormat') {
        const updated = updateDesignTokenInterchangeFormat(node, factory);
        if (updated !== node) {
          return updated;
        }
      }
      if (ts.isInterfaceDeclaration(node) && node.name.text === 'TokenMemberMap') {
        return replaceTokenMemberInterface(node, factory, tokenMemberPrefix);
      }
      return ts.visitEachChild(node, visit, context);
    };
    return (node) => ts.visitNode(node, visit);
  };

  const result = ts.transform(sourceFile, [transformer]);
  const [transformed] = result.transformed;
  result.dispose();

  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const printed = printer.printFile(transformed);
  return normalizeSchemaTypes(printed);
}

export async function compileSchemaTypes(schemaPath, options = {}) {
  const { cwd } = options;
  const schema = JSON.parse(await fs.readFile(schemaPath, 'utf8'));
  const compiled = await compileFromFile(schemaPath, {
    cwd,
    bannerComment
  });

  return applySchemaTypeTransforms(compiled, schema);
}
